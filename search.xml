<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[判断浏览器是否支持 webp 的几种解决方法]]></title>
      <url>%2F%E5%88%A4%E6%96%AD%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%AF%E5%90%A6%E6%94%AF%E6%8C%81-webp-%E7%9A%84%E5%87%A0%E7%A7%8D%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95.html</url>
      <content type="text"><![CDATA[我们都知道，WebP 是 Google 推出的 WebP 图片格式，它是一种支持有损压缩和无损压缩的图片文件格式，根据Google测试，相同的图片，WebP 格式的图片均能比 PNG，JPG 格式的图片节约不少体积，但是其兼容性不是很好，如下：因此我们需要做一些兼容处理，那么如何判断浏览器支持 webp 呢？下面有几种方法可供参考。方法一使用 canvas 的 toDataURL 进行判断toDataURL方法在MDN解释如下：HTMLCanvasElement.toDataURL() 方法返回一个包含图片展示的 data URI 。可以使用 type 参数其类型，默认为 PNG 格式。图片的分辨率为96dpi。如果画布的高度或宽度是0，那么会返回字符串“data:,”。如果传入的类型非“image/png”，但是返回的值以“data:image/png”开头，那么该传入的类型是不支持的。Chrome支持“image/webp”类型。toDataURL方法将图片转化为包含dataURI的DOMString，通过 base64 编码前面的图片类型值是image/webp进行判断。比如在谷歌浏览器使用toDataURL方法转成image/webp：在 Safari 浏览器使用toDataURL方法转成image/webp：可以发现在不支持 webp 的浏览器进行toDataURL，得到的图片类型并不是 webp，因此我们可以通过这个进行判断。实现方法：123456789var isSupportWebp = function () &#123; try &#123; return document.createElement('canvas').toDataURL('image/webp', 0.5).indexOf('data:image/webp') === 0; &#125; catch(err) &#123; return false; &#125;&#125;isSupportWebp()方法二在服务端根据请求header信息判断浏览器是否支持webp谷歌浏览器上请求图片 header是这样的：IE 浏览器请求图片 header是这样的：在图片请求发出的时候，Request Headers 里有 Accept，服务端可以根据Accept 里面是否有 image/webp 进行判断。方法三通过加载一张 webp 图片进行判断123456789101112131415161718192021222324252627282930313233343536const supportsWebp = (&#123; createImageBitmap, Image &#125;) =&gt; &#123; if (!createImageBitmap || !Image) return Promise.resolve(false); return new Promise(resolve =&gt; &#123; const image = new Image(); image.onload = () =&gt; &#123; createImageBitmap(image) .then(() =&gt; &#123; resolve(true); &#125;) .catch(() =&gt; &#123; resolve(false); &#125;); &#125;; image.onerror = () =&gt; &#123; resolve(false); &#125;; image.src = 'data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAAAAAAfQ//73v/+BiOh/AAA='; &#125;);&#125;;const webpIsSupported = () =&gt; &#123; let memo = null; return () =&gt; &#123; if (!memo) &#123; memo = supportsWebp(window); &#125; return memo; &#125;;&#125;;webpIsSupported()().then(res =&gt; &#123; console.log("是否支持 webp", res)&#125;).catch(err =&gt; &#123; console.log(err)&#125;)此方法会加载一张 1x1 的白色的正方形背景图，用来测试浏览器是否支持 webp。在 Google 测试代码：在 Firefox 测试代码：在 Safari 测试代码：Google官方文档是这样处理的（先加载一个WebP图片，如果能获取到图片的宽度和高度，就说明是支持WebP的，反之则不支持）：1234567891011121314151617function check_webp_feature(feature, callback) &#123; var kTestImages = &#123; lossy: "UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA", lossless: "UklGRhoAAABXRUJQVlA4TA0AAAAvAAAAEAcQERGIiP4HAA==", alpha: "UklGRkoAAABXRUJQVlA4WAoAAAAQAAAAAAAAAAAAQUxQSAwAAAARBxAR/Q9ERP8DAABWUDggGAAAABQBAJ0BKgEAAQAAAP4AAA3AAP7mtQAAAA==", animation: "UklGRlIAAABXRUJQVlA4WAoAAAASAAAAAAAAAAAAQU5JTQYAAAD/////AABBTk1GJgAAAAAAAAAAAAAAAAAAAGQAAABWUDhMDQAAAC8AAAAQBxAREYiI/gcA" &#125;; var img = new Image(); img.onload = function () &#123; var result = (img.width &gt; 0) &amp;&amp; (img.height &gt; 0); callback(feature, result); &#125;; img.onerror = function () &#123; callback(feature, false); &#125;; img.src = "data:image/webp;base64," + kTestImages[feature];&#125;参考HTMLCanvasElement.toDataURL()Detect WEBP Support with JavaScript探究WebP一些事儿]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript中的Object.freeze与const之间的区别(译)]]></title>
      <url>%2FJavaScript%E4%B8%AD%E7%9A%84Object-freeze%E4%B8%8Econst%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB-%E8%AF%91.html</url>
      <content type="text"><![CDATA[原文：The differences between Object.freeze() vs Const in JavaScript作者：Bolaji Ayodeji本文经授权翻译转载，版权归原作者所有！自ES6发布以来，ES6给JavaScript带来了一些新特性和方法。对于JavaScript开发者来说，这些特性能够很好地改善了我们的工作流程以及工作效率，其中的特性就包括 Object.freeze() 方法和 const 。一些开发人员特别是新手们会认为这两个功能的工作方式是一样的，但其实并不是。 让我来告诉你Object.freeze() 和 const 是如何不同的。综述const 和 Object.freeze() 完全不同。const 的行为像 let 。它们唯一的区别是， const 定义了一个无法重新分配的变量。 通过 const 声明的变量是具有块级作用域的，而不是像 var 声明的变量具有函数作用域。Object.freeze() 接受一个对象作为参数，并返回一个相同的不可变的对象。这就意味着我们不能添加，删除或更改对象的任何属性。可变对象的属性能够进行更改，而不可变对象在创建对象后不能更改其属性。例子const12const user = 'Bolaji Ayodeji'user = 'Joe Nash'这个例子会抛出一个Uncaught TypeError，因为我们正在尝试重新分配使用const关键字声明的变量user，这样做是无效的。这个例子中使用 let 或者 var 声明是能够正常工作的，但是使用 const 并不能。const 的问题使用const声明的对象仅能阻止其重新分配，但是并不能使其声明的对象具有不可变性（能够阻止更改其属性）。参考以下代码，我们使用const关键字声明了一个变量，并为其分配了一个名为user的对象。1234567891011const user = &#123; first_name: 'bolaji', last_name: 'ayodeji', email: 'hi@bolajiayodeji.com', net_worth: 2000&#125;user.last_name = 'Samson';// this would work, user is still mutable!user.net_worth = 983265975975950;// this would work too, user is still mutable and getting rich :)!console.log(user); // user is mutated尽管我们无法重新分配这个名为 user 的变量，但是我们仍然可以改变其对象本身。1234const user = &#123; user_name: 'bolajiayodeji'&#125;// won't work我们肯定希望对象具有无法修改或删除的属性。 const 无法实现这样的功能，但是 Object.freeze 可以。Object.freeze()要禁用对象的任何更改，我们需要使用 Object.freeze() 。123456789101112const user = &#123; first_name: 'bolaji', last_name: 'ayodeji', email: 'hi@bolajiayodeji.com', net_worth: 2000&#125;Object.freeze(user);user.last_name = 'Samson';// this won't work, user is still immutable!user.net_worth = 983265975975950;// this won't work too, user is still immutable and still broke :(!console.log(user); // user is immutated具有嵌套属性的对象实际上并未冻结Object.freeze 只是做了层浅冻结，当遇到具有嵌套属性的对象的时候，我们需要递归Object.freeze 来冻结具有嵌套属性的对象。123456789101112131415const user = &#123; first_name: 'bolaji', last_name: 'ayodeji', contact: &#123; email: 'hi@bolajiayodeji.com', telephone: 08109445504, &#125;&#125;Object.freeze(user);user.last_name = 'Samson';// this won't work, user is still immutable!user.contact.telephone = 07054394926;// this will work because the nested object is not frozenconsole.log(user);因此，当具有嵌套属性的对象时， Object.freeze() 并不能完全冻结对象。要完全冻结具有嵌套属性的对象，您可以编写自己的库或使用已有的库来冻结对象，如Deepfreeze 或 immutable-js结论const 和 Object.freeze() 并不同， const 是防止变量重新分配，而 Object.freeze() 是使对象具有不可变性。感谢阅读，干杯！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Git 更新 commit 的内容和多个 commit 合并]]></title>
      <url>%2FGit-%E6%9B%B4%E6%96%B0-commit-%E7%9A%84%E5%86%85%E5%AE%B9%E5%92%8C%E5%A4%9A%E4%B8%AA-commit-%E5%90%88%E5%B9%B6.html</url>
      <content type="text"><![CDATA[场景1有时候我们发现 commit 写的不好，想要更改当前分支最近一次的 commit 的内容，我们可以使用：1git commit --amend场景二既然可以更改最近一次的 commit，那可能有些人就想要在当前分支下前几次的 commit 内容进行更改或者进行 commit 合并，那我们需要怎么做呢？方法如下：（注意此操作最好是在自己维护的分支上弄，多人开发的分支就不太适合）使用git rebase -i xxxx,这里的 i 指的是交互的意思现在项目 commit 如下我现在想要更改第二个 commit 的内容，那我需要知道当前要修改的 commit 的父亲的 id，也就是 init game 的 commit id 1801cf5，然后git rebase -i 1801cf5：当前是 pick，我们需要使用 reword 来更改第二个 commit 的内容保存退出，出现修改 commit 内容，然后退出，出现git log —oneline 查看成功添加.号场景3现在我们想要把第二个 commit 和第一个 commit 这两个连续的 commit 进行合并，我们可以这样：同样使用git rebase -i 1801cf5,将第二个 pick 改为 s(squash)，这样可以合并到上一个commit保存退出修改成保存退出git log —oneline 查看成功合并。场景4现在有人又有个疑惑，如果我是相隔的 commit，但是我想将相隔的 commit 的内容进行合并，那又需怎么做呢？还是以下面这个为例子现在我们想将第一个 commit 的内容和第三个内容进行合并，这里你可能你比较疑惑，第三个 commit 的上一个 commit 是没有的，那怎么用 rebase 呢？我们需要记下第三个 commit 的 id，输入git rebase -i 1801cf5目前只有两个，没有 init game 的 commit id，我们需要将这个 commit id 添加上去（我们可以不用写commit 的内容）：将相关要合并的 commit 写在一起：保存退出。按照之前的步骤即可。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[使用 VSCode 调试 Koa 或者 Express 项目]]></title>
      <url>%2F%E4%BD%BF%E7%94%A8-VSCode-%E8%B0%83%E8%AF%95-Koa-%E6%88%96%E8%80%85-Express.html</url>
      <content type="text"><![CDATA[前言平常调试 node 打 log 打习惯了，突然发现一个问题就是打印对象的时候，尤其这个对象里面有很多属性的时候，在终端上得一直往上拉才能看到，因此打算使用 vscode 来打断点调试程序。安装这里的例子是使用 koa ，express 类似。我是使用阿里巴巴的飞冰快速搭建一个后台和前台的项目。下载飞冰打开飞冰，使用ICE Design Pro模板并点击 添加koa2，如下自动安装完成后，使用 vscode 打开项目：打开终端，运行npm run client 这个时候前端项目就运行起来了。稍微修改一下前端的代码，因为这个模板默认是使用前端直接返回数据，而不去请求接口，打开client/pages/UserLogin/actions.js,将 import {login} from &#39;../../api/user&#39;;改为 import {login} from &#39;../../api/index&#39;;就可以了。最后打开页面，地址终端里面有说明。编写launch.jsonVsCode左侧第四个按钮是调试按钮，默认是『没有配置』。点击右侧的齿轮状图标，选择Node.js 会在项目根目录下创建 .vscode 的文件夹及 launch.json 文件。launch.json 内容如下：1234567891011121314&#123; // 使用 IntelliSense 了解相关属性。 // 悬停以查看现有属性的描述。 // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387 "version": "0.2.0", "configurations": [ &#123; "type": "node", "request": "launch", "name": "启动程序", "program": "$&#123;workspaceFolder&#125;/server/index.js" &#125; ]&#125;默认会访问server下的 index.js 文件，但是这个项目的入口文件是 app.js，因此需要将index.js改为app.js。在launch.json中会使用到一些预定变量，这里说明一下：${workspaceRoot}：VSCode中打开文件夹的路径${workspaceRootFolderName}：VSCode中打开文件夹的路径, 但不包含”/“${file}：当前打开的文件${fileBasename}： 当前打开文件的文件名, 不含扩展名${fileDirname}： 当前打开文件的目录名${fileExtname} 当前打开文件的扩展名${cwd}：当前执行目录当我们在单步调试程序的时候，会进入node_modules里面，通常情况下我们并不需要去关心里面的逻辑实现，只关心项目本身的代码。在这个时候，我们就需要使用skipFiles：12345678910111213141516&#123; // 使用 IntelliSense 了解相关属性。 // 悬停以查看现有属性的描述。 // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387 "version": "0.2.0", "configurations": [&#123; "type": "node", "request": "launch", "name": "启动程序", "program": "$&#123;workspaceFolder&#125;/server/app.js", "skipFiles": [ "$&#123;workspaceRoot&#125;/node_modules/**/*.js", "&lt;node_internals&gt;/**/*.js" ] &#125;]&#125;我们还想要自动重启的功能，安装 nodemon 或者 node-dev：123// 任选其一npm i nodemon -gnpm i node-dev -g修改lanuch.json：12345678910111213141516171819&#123; // 使用 IntelliSense 了解相关属性。 // 悬停以查看现有属性的描述。 // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387 "version": "0.2.0", "configurations": [&#123; "type": "node", "request": "launch", "name": "启动程序", "program": "$&#123;workspaceFolder&#125;/server/app.js", "runtimeExecutable": "nodemon", // 或者 node-dev "restart": true, "console": "integratedTerminal", "skipFiles": [ "$&#123;workspaceRoot&#125;/node_modules/**/*.js", "&lt;node_internals&gt;/**/*.js" ] &#125;]&#125;这里新增了三个字段，分别是：runtimeExecutable：用什么命令执行 app.js，这里设置为 nodemon，默认是 noderestart：在终止 Node.js 后重启会话console：启动调试目标的位置，这里选择在 vscode 的集成终端输出信息调试这里在 server/controller/user.js 的 login 打了个断点：启动调试，如下：vscode 集成终端打印如下：在前端页面点击登录，会跳到这里：我们就能看到变量的信息啦😄（注意：如果此时终止了调试，nodemon 还是会运行，得在集成终端终止）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[nodejs 路径解析顺序]]></title>
      <url>%2Fnodejs-%E8%B7%AF%E5%BE%84%E8%A7%A3%E6%9E%90%E9%A1%BA%E5%BA%8F.html</url>
      <content type="text"><![CDATA[前言平时在使用 nodejs 去 require 的时候是不是有使用绝对路径或者相对路径去引用，那么 nodejs 解析路径顺序是怎么样的呢？接下来我会讲一下 nodejs 路径解析顺序相对路径解析顺序假设有一个文件路径为 /root/src/moduleA.js，包含了一个导入var x = require(&quot;./moduleB&quot;);, 也就是导入了一个相对路径的一个模块，那么Node.js以下面的顺序解析这个导入：到/root/src/moduleB.js这个路径是否存在，如果不存在进入下一步。检查/root/src/moduleB 目录是否包含一个package.json文件，且package.json文件指定了一个”main”模块,比如 ，Node.js发现文件 /root/src/moduleB/package.json 包含了 { &quot;main&quot;: &quot;lib/mainModule.js&quot; },那么 nodejs 就会去 /root/src/moduleB/lib/mainModule.js如果没有 main 字段,nodejs会检查/root/src/moduleB目录是否包含一个 index.js 文件。 这个文件会被隐式地当作那个文件夹下的”main”模块。绝对路径解析顺序假设有一个文件路径为/root/src/moduleA.js，里面包含了一个导入var x = require(&quot;moduleB&quot;);，也就是绝对路径的一个模块，那么Node.js以下面的顺序解析这个导入：/root/src/node_modules/moduleB.js/root/src/node_modules/moduleB/package.json（里面指定了 main 字段，跟上面相对路径是一样的）/root/src/node_modules/moduleB/index.js如果上面三个没有找到，往上一级目录找：/root/node_modules/moduleB.js/root/node_modules/moduleB/package.json/root/node_modules/moduleB/index.js如果还没有找到，继续往上一级找：/node_modules/moduleB.js/node_modules/moduleB/package.json/node_modules/moduleB/index.js]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[四种方法实现数据双向绑定]]></title>
      <url>%2F%E5%9B%9B%E7%A7%8D%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A.html</url>
      <content type="text"><![CDATA[前言在一些前端框架中，例如 angular，vue都有数据双向数据绑定的功能，这个功能极大的方便我们操作数据。那么接下来我会讲解一下双向数据绑定的4种实现方式。方式1.手动触发绑定手动触发绑定的主要思路是通过在数据对象定义 get 和 set 方法(可以使用其他的命名方法)，调用时手动去触发 get 和 set 方法去获取数据，修改数据，改变数据后会主动去触发 get 和 set 函数中视图层的重新渲染。简单的手动触发绑定代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;手动双向绑定&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;input type="text" id="input" s-value="value"&gt; &lt;span id="el" s-text="value"&gt;&lt;/span&gt; &lt;script&gt; let elems = [document.getElementById('el'), document.getElementById('input')]; let data = &#123; value: '' &#125; let directive = &#123; text: function (text) &#123; this.innerHTML = text &#125;, value: function (value) &#123; this.setAttribute('value', value) &#125; &#125; // 监听 input 的 keyup 事件 elems[1].addEventListener('keyup', function (e) &#123; set('value', e.target.value) &#125;) function scan() &#123; for (let elem of elems) &#123; for (let attr of elem.attributes) &#123; if (attr.nodeName.indexOf('s-') !== -1) &#123; // 调用属性指令 directive[attr.nodeName.slice(2)].call(elem, data[attr.nodeValue]) &#125; &#125; &#125; &#125; function set(key, value) &#123; data[key] = value; scan(); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;2.数据劫持数据劫持的基本思路是使用 Object.defineProperty 对 ViewModel 数据对象进行 get 和 set 的监听，当有数据变动的时候扫描元素节点，然后去运行对应节点上的指令（directive）。代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;数据劫持&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;input type="text" id="input" s-value="value"&gt; &lt;span id="el" s-text="value"&gt;&lt;/span&gt; &lt;script&gt; let elems = [document.getElementById('el'), document.getElementById('input')]; let data = &#123; value: '' &#125; let directive = &#123; text: function (text) &#123; this.innerHTML = text &#125;, value: function (value) &#123; this.setAttribute('value', value) &#125; &#125; let value; defineGetAndSet(data, 'value') // 监听 input 的 keyup 事件 elems[1].addEventListener('keyup', function (e) &#123; data.value = e.target.value; &#125;) function scan() &#123; for (let elem of elems) &#123; for (let attr of elem.attributes) &#123; if (attr.nodeName.indexOf('s-') !== -1) &#123; // 调用属性指令 directive[attr.nodeName.slice(2)].call(elem, data[attr.nodeValue]) &#125; &#125; &#125; &#125; function defineGetAndSet(obj, attrName) &#123; Object.defineProperty(obj, attrName, &#123; get: function () &#123; return value &#125;, set: function (newValue) &#123; value = newValue; scan() &#125;, configurable: true, enumerable: true &#125;) &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;3.使用 es6的 Proxy利用Proxy ，它可以目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此可以对外界的访问进行过滤和改写，实现数据双向数据绑定和上一个类似。代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;使用 proxy 进行数据双向绑定&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;input type="text" id="input" s-value="value"&gt; &lt;span id="el" s-text="value"&gt;&lt;/span&gt; &lt;script&gt; let elems = [document.getElementById('el'), document.getElementById('input')]; let directive = &#123; text: function (text) &#123; this.innerHTML = text &#125;, value: function (value) &#123; this.setAttribute('value', value) &#125; &#125; // ------------- 看下面 ------------- let data = new Proxy(&#123;&#125;, &#123; get: function (target, key, receiver) &#123; return target.value &#125;, set(target, key, value, receiver) &#123; target.value = value; scan(); &#125; &#125;) // ------------- 看上面 ------------- // 监听 input 的 keyup 事件 elems[1].addEventListener('keyup', function (e) &#123; data.value = e.target.value; &#125;) function scan() &#123; for (let elem of elems) &#123; for (let attr of elem.attributes) &#123; if (attr.nodeName.indexOf('s-') !== -1) &#123; // 调用属性指令 directive[attr.nodeName.slice(2)].call(elem, data[attr.nodeValue]) &#125; &#125; &#125; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;4. 脏检查脏检查的基本原理是在 ViewModel 对象的某个属性值发生变化的时候找到与这个属性值相关的所有元素，然后去比较数据变化，如果变化就用 directive 指令调用，对这个元素进行重新渲染。简单的脏检查代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;脏检查&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;input type="text" id="input" s-bind="value" s-event="value"&gt; &lt;span id="el" s-event="text" s-bind="value"&gt;&lt;/span&gt; &lt;script&gt; let elems = [document.getElementById('el'), document.getElementById('input')]; let directives = &#123; text: function (text) &#123; this.innerHTML = text &#125;, value: function (value) &#123; this.setAttribute('value', value) &#125; &#125; let data = &#123; value: '' &#125; // 扫描元素，使每个元素的 directive 数组为空 scan(elems) // 监听 input 的 keyup 事件 elems[1].addEventListener('keyup', function (e) &#123; data.value = e.target.value; startDirtyCheck(e.target.getAttribute('s-bind')) &#125;) function scan() &#123; for (let elem of elems) &#123; elem.directive = [] &#125; &#125; // 开启脏检查 function startDirtyCheck(value) &#123; let list = document.querySelectorAll('[s-bind=' + value + ']') dirtyCheck(list) &#125; function dirtyCheck(elems) &#123; // 扫描带指令的节点属性 for (let i = 0, len = elems.length; i &lt; len; i++) &#123; let elem = elems[i]; for (let j = 0, len1 = elem.attributes.length; j &lt; len1; j++) &#123; let attr = elem.attributes[j]; if (attr.nodeName.indexOf('s-event') !== -1) &#123; let dataKey = elem.getAttribute('s-bind') // 进行脏数据检查，如果数据改变，重新执行指令 if (elem.directive[attr.nodeValue] !== data[dataKey]) &#123; directives[attr.nodeValue].call(elem, data[dataKey]) elem.directive[attr.nodeValue] = data[dataKey] &#125; &#125; &#125; &#125; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[react-native问题汇总]]></title>
      <url>%2Freact-native%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB.html</url>
      <content type="text"><![CDATA[前言前些天使用react-native 写了个项目，遇到的问题挺多的，在这里记录下来📝，避免忘记。本篇文章会不定期更新!问题汇总问题一出现Remote debugger is in a background tab which may cause apps to perform slowly黄色警报解决方法把那个chrome的Tab页保持最前，窗口不要最小化就好了。。。。问题二出现connection to http://localhost:8081 红色错误解决方法这个很神奇。遇到了多按 ⌘R几下或者把模拟器上的项目删除之后重新加载一般就会解决。bad news: metro v0.29.0 won’t work with RN 0.54-0.55 because it introduced a new config param that RN is not handling yet (we’re working on improving configuration compatibility between RN and metro).good news: the actual fix needed to solve this issue is in the RN repo (7be3d1c), so cherry-picking it into the 0.54 and 0.55 branches and releasing a RN minor version will fix this. (cc @hramos, @grabbou ).或者使用下面命令可以解决问题1yarn cache clean&amp;&amp;yarn问题三出现Runtime is not ready for debugging红色错误两种解决方法关掉http://localhost:8081/debugger-ui/ 再重新开启就行了按 command+d 将Debug JS Remotely关掉也可以问题四出现Unrecognized font family 红色报警解决方法在终端输入1react-native link react-native-vector-icons然后重新启动即可问题五React Native不支持自动计算Image等View的大小详情问题六react-native-interactable 出现 Invariant Violation红色警报解决方法降级：将 react-native 版本降到0.53.0 就行了参考 wix/react-native-interactable#185问题七Build后遇到’No bundle URL present’ error解决方法关闭SS,VPN这类的服务，重新 react-native run-ios 即可。很神奇。。。官方也有这个 issue问题八出现regeneratorRuntime is not defined解决方法1react-native start --reset-cache最终原因是因为一个组件没删干净🤣问题九出现:CFBundleIdentifier”, Does Not Exist 错误解决方法打开 xcode 运行项目出现在这里面有个 libInteractable.a 删除掉就行了参考：rebeccahughes/react-native-device-info#251问题十删除包注意事项首先 react-native unlink &lt;lib name&gt;然后 yarn remove &lt;lib name&gt;一定要这样做不然会有问题。。。问题十一出现Invariant Violation: View config not found for name 红色警报解决方法https://stackoverflow.com/questions/46750477/react-native-invariant-violation-view-config问题十二Button 组件无法直接使用 style定宽度和高度等等解决方法If this button doesn’t look right for your app, you can build your own button using TouchableOpacity or TouchableNativeFeedback.也就是说可以使用 TouchableOpacity 或者 TouchableNativeFeedback 组件代替问题十三使用TouchableWithoutFeedback 出现错误解决方法TouchableWithoutFeedback，这个组件必须至少有一个child，如果是多个组件，必须以view来包装。写成这样就可以了12345678910render() &#123; return( &lt;TouchableWithoutFeedback style=&#123;&#123;flex: 1&#125;&#125; onPress=&#123;dismissKeyboard&#125;&gt; &lt;View style=&#123;&#123;flex: 1&#125;&#125;&gt; 。。。。。。。。。。 &lt;/View&gt; &lt;/TouchableWithoutFeedback&gt; );&#125;问题十四xcode出现Showing All Messages Code signing is required for product type ‘Unit Test Bundle’ in SDK ‘iOS 11.2’在Xcode上即可问题十五react-navigation TabNavigator点击切换反应迟钝。在真机上调试react-navigation的TabNavigator，点击tab总感觉反应很慢，试了好久都是这样，大概有0.5秒之后才会切换体验很差。解决方法关闭debug模式。。。。问题十六React Navigation TabNavigator 一个帧的延迟当页面加载时，下面的 tab 图标从第一个到第二个图标有一个帧的延迟解决方法定义initialLayout，用以防止react-native-tab-view渲染中一个帧的延迟参考：https://github.com/react-native-community/react-native-tab-view#avoid-one-frame-delay问题十七出现timed out waiting for 红色警报解决方法重启模拟器。。。问题十八react native 没有\组件换行解决方法可以在 Text 组件里写 {‘\n’},如：问题十九react native checkbox 原生组件只适合安卓解决方法可以使用这个 https://github.com/crazycodeboy/react-native-check-box问题二十react-navigation的headerRight添加点击事件解决方法首先需要在componentDidMount(){}中动态的添加点击事件12345componentDidMount()&#123; this.props.navigation.setParams(&#123; navigatePress:this.navigatePress &#125;)&#125;然后1234navigatePress = () =&gt; &#123; alert('点击headerRight'); console.log(this.props.navigation);&#125;接下来就可以通过params方法来获取点击事件了（记住先要判断navigation.state.params是否存在，不然会报错。。。）12345678static navigationOptions = (&#123; navigation, screenProps &#125;) =&gt; (&#123; title: navigation.state.params?navigation.state.params.title:null, headerRight:( &lt;Text onPress=&#123;navigation.state.params?navigation.state.params.navigatePress:null&#125;&gt; 返回 &lt;/Text&gt; )&#125;);问题二十一react-navigation tab 点击 StatusBar 颜色问题解决方法详情 https://reactnavigation.org/docs/status-bar.html问题二十二Image 标签不支持 http 问题解决方法ios 9 以上，默认是Https请求，如需支持Http，修改info.plist文件添加键值对就好了问题二十三react-native-swiper 动态数据渲染，翻页出现错乱出现一开始，使用静态的数据没问题，但是使用动态加载数据就出现问题，经过一些调试发现，可能是 index 的问题，在 github 库里搜 issue 果然有人遇到过这个问题 https://github.com/leecade/react-native-swiper/issues/720解决方法添加 key 值是你获取数据的长度问题二十四react-native-swiper 跳转索引 bug 问题。一开始在翻页的时候，出现索引随机变化的问题，当时看了一下 api 是没有问题的，一直定位到将标题不显示就发现索引没有问题了，不会随机翻页。。。，接着在某一页看到题目比较大，发生了抖动，结果造成了随机翻页，再一看里面有数字和文字，大小不一样，设置一下字体就好了。。。。个人认为是抖动的时候可能触发了react-native-swiper的翻页，结果造成随机翻页。。。神坑的 bug，找了4，5个小时。。。。😡问题二十五ListView, FlatList, Sections and VirtualizedList paddingBottom 无效的问题。ListView, FlatList, Sections and VirtualizedList 继承了 ScrollView所以导致都有这个问题解决方法1&lt;ScrollView contentContainerStyle=&#123;&#123;paddingBottom: 16&#125;&#125; /&gt;问题二十六出现 could not connect to development server红色警报解决方法关掉 vpn ，或者不要开全局模式。。。很神奇]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[html5调用摄像头功能]]></title>
      <url>%2Fhtml5%E8%B0%83%E7%94%A8%E6%91%84%E5%83%8F%E5%A4%B4%E5%8A%9F%E8%83%BD.html</url>
      <content type="text"><![CDATA[前言前些天，线上笔试的时候，发现需要浏览器同意开启摄像头，感觉像是 js 调用的，由于当时笔试，也就没想到这么多🤣。今天闲来无事，看了下自己的 todo，发现有这个调用摄像头的todo，才想到😂。网上查了一下，果然 js 有调用摄像头的 api，为此自己写一个 demo ，避免忘记。正文调用摄像头一共有两种实现方式，一种是使用navigator.getUserMedia（该特性已经从 Web 标准中删除，虽然一些浏览器目前仍然支持它，但也许会在未来的某个时间停止支持，请尽量不要使用该特性），前面一种已经从 Web 标准中删除，仅为了向后兼容而存在，第二种是使用navigator.mediaDevices.getUserMedia(推荐使用),这两种方法 Safari 貌似都不支持。。。。第一种方法navigator.getUserMedia用法详见 mdn ，代码如下：123456789101112131415161718192021222324252627282930313233343536373839&lt;!doctype html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;摄像头调用1&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;video id="v"&gt;&lt;/video&gt; &lt;script&gt; !(function () &#123; function userMedia() &#123; return navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia || null; &#125; if (userMedia()) &#123; var constraints = &#123; video: true, audio: false &#125;; var media = navigator.getUserMedia(constraints, function (stream) &#123; var v = document.getElementById('v'); var url = window.URL || window.webkitURL; v.src = url ? url.createObjectURL(stream) : stream; v.play(); &#125;, function (error) &#123; console.log("ERROR"); console.log(error); &#125;); &#125; else &#123; console.log("不支持"); &#125; &#125;)(); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;第二种方法navigator.mediaDevices.getUserMedia用法详见mdn。navigator.mediaDevices.getUserMedia 其实和第一种差不多，主要第二种返回是一个 Promise 对象，代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;!doctype html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;摄像头调用2&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;video id="v"&gt;&lt;/video&gt; &lt;script&gt; !(function () &#123; // 老的浏览器可能根本没有实现 mediaDevices，所以我们可以先设置一个空的对象 if (navigator.mediaDevices === undefined) &#123; navigator.mediaDevices = &#123;&#125;; &#125; if (navigator.mediaDevices.getUserMedia === undefined) &#123; navigator.mediaDevices.getUserMedia = function (constraints) &#123; // 首先，如果有getUserMedia的话，就获得它 var getUserMedia = navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia; // 一些浏览器根本没实现它 - 那么就返回一个error到promise的reject来保持一个统一的接口 if (!getUserMedia) &#123; return Promise.reject(new Error('getUserMedia is not implemented in this browser')); &#125; // 否则，为老的navigator.getUserMedia方法包裹一个Promise return new Promise(function (resolve, reject) &#123; getUserMedia.call(navigator, constraints, resolve, reject); &#125;); &#125; &#125; const constraints = &#123; video: true, audio: false &#125;; let promise = navigator.mediaDevices.getUserMedia(constraints); promise.then(stream =&gt; &#123; let v = document.getElementById('v'); // 旧的浏览器可能没有srcObject if ("srcObject" in v) &#123; v.srcObject = stream; &#125; else &#123; // 防止再新的浏览器里使用它，应为它已经不再支持了 v.src = window.URL.createObjectURL(stream); &#125; v.onloadedmetadata = function (e) &#123; v.play(); &#125;; &#125;).catch(err =&gt; &#123; console.error(err.name + ": " + err.message); &#125;) &#125;)(); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;拍照思路是设置一个标志变量 videoPlaying 看看是否 video 有在 play，监听拍照按钮的点击事件，如果videoPlaying 为 true ，使用一个canvas 获取 video 的宽高（默认 canvas 是不显示的），然后使用 canvas 的drawImage,然后使用 canvas 的 toDataURL返回一个 data url，将这个 url，设置在一个 img 标签上即可😀第一种方法navigator.getUserMedia实现代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;!doctype html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;拍照1&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;button id="take"&gt;拍照&lt;/button&gt; &lt;br /&gt; &lt;video id="v" style="width: 640px;height: 480px;"&gt;&lt;/video&gt; &lt;canvas id="canvas" style="display:none;"&gt;&lt;/canvas&gt; &lt;br /&gt; &lt;img src="http://placehold.it/640&amp;text=Your%20image%20here%20..." id="photo" alt="photo"&gt; &lt;script&gt; !(function () &#123; function userMedia() &#123; return navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia || null; &#125; if (userMedia()) &#123; let videoPlaying = false; let constraints = &#123; video: true, audio: false &#125;; let video = document.getElementById('v'); let media = navigator.getUserMedia(constraints, function (stream) &#123; let url = window.URL || window.webkitURL; video.src = url ? url.createObjectURL(stream) : stream; video.play(); videoPlaying = true; &#125;, function (error) &#123; console.log("ERROR"); console.log(error); &#125;); document.getElementById('take').addEventListener('click', function () &#123; if (videoPlaying) &#123; let canvas = document.getElementById('canvas'); canvas.width = video.videoWidth; canvas.height = video.videoHeight; canvas.getContext('2d').drawImage(video, 0, 0); let data = canvas.toDataURL('image/webp'); document.getElementById('photo').setAttribute('src', data); &#125; &#125;, false); &#125; else &#123; console.log("不支持"); &#125; &#125;)(); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;第二种navigator.mediaDevices.getUserMedia实现方法:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&lt;!doctype html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;拍照2&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;button id="take"&gt;拍照&lt;/button&gt; &lt;br /&gt; &lt;video id="v" style="width: 640px;height: 480px;"&gt;&lt;/video&gt; &lt;canvas id="canvas" style="display:none;"&gt;&lt;/canvas&gt; &lt;br /&gt; &lt;img src="http://placehold.it/640&amp;text=Your%20image%20here%20..." id="photo" alt="photo"&gt; &lt;script&gt; !(function () &#123; // 老的浏览器可能根本没有实现 mediaDevices，所以我们可以先设置一个空的对象 if (navigator.mediaDevices === undefined) &#123; navigator.mediaDevices = &#123;&#125;; &#125; if (navigator.mediaDevices.getUserMedia === undefined) &#123; navigator.mediaDevices.getUserMedia = function (constraints) &#123; // 首先，如果有getUserMedia的话，就获得它 var getUserMedia = navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia; // 一些浏览器根本没实现它 - 那么就返回一个error到promise的reject来保持一个统一的接口 if (!getUserMedia) &#123; return Promise.reject(new Error('getUserMedia is not implemented in this browser')); &#125; // 否则，为老的navigator.getUserMedia方法包裹一个Promise return new Promise(function (resolve, reject) &#123; getUserMedia.call(navigator, constraints, resolve, reject); &#125;); &#125; &#125; const constraints = &#123; video: true, audio: false &#125;; let videoPlaying = false; let v = document.getElementById('v'); let promise = navigator.mediaDevices.getUserMedia(constraints); promise.then(stream =&gt; &#123; // 旧的浏览器可能没有srcObject if ("srcObject" in v) &#123; v.srcObject = stream; &#125; else &#123; // 防止再新的浏览器里使用它，应为它已经不再支持了 v.src = window.URL.createObjectURL(stream); &#125; v.onloadedmetadata = function (e) &#123; v.play(); videoPlaying = true; &#125;; &#125;).catch(err =&gt; &#123; console.error(err.name + ": " + err.message); &#125;) document.getElementById('take').addEventListener('click', function () &#123; if (videoPlaying) &#123; let canvas = document.getElementById('canvas'); canvas.width = v.videoWidth; canvas.height = v.videoHeight; canvas.getContext('2d').drawImage(v, 0, 0); let data = canvas.toDataURL('image/webp'); document.getElementById('photo').setAttribute('src', data); &#125; &#125;, false); &#125;)(); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[2018春招面试总结]]></title>
      <url>%2F2018%E6%98%A5%E6%8B%9B%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93.html</url>
      <content type="text"><![CDATA[前言从3月底到4月中旬，经过半个月的面试，终于在4月17号顺利拿到了阿里的 offer，感谢这段时间内面试官、家人和朋友的帮助和鼓励。下面我会总结一些企业关注的点和面试的一些技巧。企业关注的点我认为大企业招聘技术实习生或者是应届生时关注有以下几点：你的学历（很重要，我腾讯现场二面估计就是挂在这上面，一上来就问我学校的排名😂）你的成绩排名你的项目经验你的比赛奖项（关注会比较少，除非是获得 acm 那种大型比赛）对技术是否热情你的计算机基础你的价值观你的性格你对当前应聘岗位的知识储备沟通能力和团队协作是否能够主动去学习新的东西在面试时，这些方面都会有所体现。比如问你一些常规性问题（考察你对当前应聘岗位的知识储备）。问你一些计算机基础问题（考察你的计算机基础）。HR 问你一些关于性格优缺点和一些其他问题（考察你的性格和你的价值观）。问你一些场景题（考察你的项目经验）。问你最近看什么书或者你常逛什么技术社区（考察你是否能够主动去学习新的东西和你对技术是否有热情）等等。面试技巧首先，在面试中，一定要自信不要紧张。遇到不会的问题不要慌张，可以将不会的问题转化为自己会的问题。我举个例子，比如面试官问你前端的async 和 await ，那么此时如果你这个不会，那么你可以问一下面试官这个主要是干嘛的，面试官一般都会跟你解释，他告诉你这是异步，那么你就可以往异步的方面靠，这样会让面试官觉得你掌握的还行🙂。其次，就是简历的项目经验和技能一定要写好，因为面试官会一直问项目的实现，难点，和项目产生的背景。然后会问你在简历上的一些相关技能。个人认为如果不太会的技能就不要写上去。比如我写了了解前端安全和性能优化，然后很多面试官就问这个。。。一直问。。。还好准备的比较充分，不然就 gg 了🤣最后，在面试时，千万不要抱怨你的队友，即便队友很水。我举个反例，有人在 hr 面试时，hr 问他对队友看法，然后他说队友很水，整个项目都是他在写，然后当天就挂了。你想，企业会要背后说别人闲话的人吗？最后的最后，面试一定要保持积极的心态，就当面试是在自我学习的过程，每次面试都自我反省一下，到底哪些问题回答不好，然后去查缺补漏，这样一定会收获到一个自己满意的 offer 😀]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[vue全家桶与typescript使用总结]]></title>
      <url>%2Fvue%E5%85%A8%E5%AE%B6%E6%A1%B6%E4%B8%8Etypescript%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93.html</url>
      <content type="text"><![CDATA[前言最近重构了我之前项目 qq 音乐移动端，使用的技术是 vue，vuex，vue-router，和 typescript，在这期间，遇到的问题还是蛮多的，一会儿我会把我遇到的问题以及解决方法列出来，避免忘记。重构完成的项目 ===&gt; vue-qq-musicTypeScript与Vue全家桶的配置可以参考以下两篇文章（在这里由衷感谢两位作者）：vue + typescript 新项目起手式Vue2.5+ Typescript 引入全面指南 - Vuex篇TypeScript为什么我要将TypeScript 和 Vue 集成呢？因为TypeScript 有以下几个优势：可读性。TypeScript 是 JavaScript 的超集，这意味着他支持所有的 JavaScript 语法。并在此之上对 JavaScript 添加了一些扩展，如interface等。这样会大大提升代码的可阅读性静态类型检查。静态类型检查可以避免很多不必要的错误，不用在调试的时候才发现问题。代码提示。ts 搭配 vscode，代码提示非常友好代码重构。例如全项目更改某个变量名（也可以是类名、方法名，甚至是文件名[重命名文件自动修改的是整个项目的import]），在JS中是不可能的，而TS可以轻松做到。看看下面发生了什么神奇的事情😁⬇️遇到的问题以及解决方法问题一ts 无法识别$ref解决方法① 直接在 this.$refs.xxx 后面申明类型如：1this.$refs.lyricsLines as HTMLDivElement;② 在export default class xxx extends Vue里面声明全部的$ref 的类型1234$refs: &#123; audio: HTMLAudioElement, lyricsLines: HTMLDivElement&#125;问题二ts 无法识别 require解决方法安装声明文件1yarn add @types/webpack-env -D问题三运行npm run build 出现解决方法You can fix this by using the most recent beta version of uglifyjs-webpack-plugin. Our team is working to remove completely the UglifyJsPlugin from within webpack, and instead have it as a standalone plugin.If you do yarn add uglifyjs-webpack-plugin@beta --dev or npm install uglifyjs-webpack-plugin@beta --save-devyou should receive the latest beta which does successfully minify es6 syntax. We are hoping to have this released from beta extremely soon, however it should save you from errors for now!也就是说升级你的uglifyjs-webpack-plugin版本：yarn add uglifyjs-webpack-plugin@beta --dev问题四vue-property-decorator 装饰器写法不对。当时我是要把 mixins，注入到组件里，我就这样写：ts提示找不到 mixin。我就很纳闷为什么找不到名字，由于官网vue-property-decorator例子太少，只好一步一步摸索😂解决方法把mixins写在@Component里面…，像这样：注意点如果你引用第三方无类型声明的库，那就需要自己编写x.d.ts文件如果引用 ui 组件的时候，如果控制台出现Property &#39;$xxx&#39; does not exist on type &#39;App&#39;的话，那么可以在vue-shim.d.ts增加12345declare module 'vue/types/vue' &#123; interface Vue &#123; $xxx: any, &#125;&#125;最后经过几天的折腾，终于把项目重构完成，我个人认为加上 TypeScript，确实效率挺高了许多，不过 Vue+TypeScript 还是没 Angular支持那么完善，相信之后 vue 对于 ts 的集成会更加完善！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[node简单实现一个更改头像功能]]></title>
      <url>%2Fnode%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%9B%B4%E6%94%B9%E5%A4%B4%E5%83%8F%E5%8A%9F%E8%83%BD.html</url>
      <content type="text"><![CDATA[前言一直想写这篇文章，无奈由于要考试的原因，一直在复习，拖延到现在才写🤣，之前用 node 的 express 框架写了个小项目，里面有个上传图片的功能，这里记录一下如何实现（我使用的是 ejs）📝思路首先，当用户点击上传头像，更新头像的时候，将头像上传到项目的一个文件夹里面（我是存放在项目的public/images/img里面），并且将图像名重命名（可以以时间戳来命名）。同时图片在项目的路径插入到用户表的当前用户的 userpicturepath 里面然后更新用户的 session，将图片里面的路径赋值给 session 的里面的picture属性里面&lt;img&gt; 的 src 获取到当前用户的session里面的 picture 的值，最后动态刷新页面头像就换成了用户上传的头像了实现效果代码ejs部分1234567&lt;img class="nav-user-photo" src="&lt;%= user.picture.replace(/public(\/.*)/, "$1") %&gt;" alt="Photo" style="height: 40px;"/&gt;&lt;form enctype="multipart/form-data" method="post" name="fileInfo"&gt; &lt;input type="file" accept="image/png,image/jpg" id="picUpload" name="file"&gt;&lt;/form&gt;&lt;button type="button" class="btn btn-primary" id="modifyPicV"&gt;确定&lt;/button&gt;js部分12345678910111213141516document.querySelector('#modifyPicV').addEventListener('click', function () &#123; let formData = new FormData(); formData.append("file",$("input[name='file']")[0].files[0]);//把文件对象插到formData对象上 console.log(formData.get('file')); $.ajax(&#123; url:'/modifyPic', type:'post', data: formData, processData: false, // 不处理数据 contentType: false, // 不设置内容类型 success:function () &#123; alert('success'); location.reload(); &#125;, &#125;)&#125;);路由部分，使用formidable，这是一个Node.js模块，用于解析表单数据，尤其是文件上传12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273let express = require('express');let router = express.Router();let fs = require('fs');let &#123;User&#125; = require('../data/db');let formidable = require('formidable');let cacheFolder = 'public/images/';//放置路径router.post('/modifyPic', function (req, res, next) &#123; let userDirPath = cacheFolder + "Img"; if (!fs.existsSync(userDirPath)) &#123; fs.mkdirSync(userDirPath);//创建目录 &#125; let form = new formidable.IncomingForm(); //创建上传表单 form.encoding = 'utf-8'; //设置编码 form.uploadDir = userDirPath; //设置上传目录 form.keepExtensions = true; //保留后缀 form.maxFieldsSize = 2 * 1024 * 1024; //文件大小 form.type = true; form.parse(req, function (err, fields, files) &#123; if (err) &#123; return res.json(err); &#125; let extName = ''; //后缀名 switch (files.file.type) &#123; case 'image/pjpeg': extName = 'jpg'; break; case 'image/jpeg': extName = 'jpg'; break; case 'image/png': extName = 'png'; break; case 'image/x-png': extName = 'png'; break; &#125; if (extName.length === 0) &#123; return res.json(&#123; msg: '只支持png和jpg格式图片' &#125;); &#125; else &#123; let avatarName = '/' + Date.now() + '.' + extName; let newPath = form.uploadDir + avatarName; fs.renameSync(files.file.path, newPath); //重命名 console.log(newPath) //更新表 User.update(&#123; picture: newPath &#125;, &#123; where: &#123; username: req.session.user.username &#125; &#125;).then(function (data) &#123; if (data[0] !== undefined) &#123; User.findAll(&#123; where: &#123; username: req.session.user.username &#125; &#125;).then(function (data) &#123; if (data[0] !== undefined) &#123; req.session.user.picture = data[0].dataValues.picture; res.send(true); &#125; else &#123; res.send(false); &#125; &#125;) &#125; &#125;).catch(function (err) &#123; console.log(err); &#125;); &#125; &#125;);&#125;);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[解决 webstrom 上的 babel 编译问题]]></title>
      <url>%2F%E8%A7%A3%E5%86%B3-webstrom-%E4%B8%8A%E7%9A%84-babel-%E7%BC%96%E8%AF%91%E9%97%AE%E9%A2%98.html</url>
      <content type="text"><![CDATA[前言近日，在写 ejs 文件时，我发现用 vscode 没有啥提示，因此换成 webStrom ，但是用 webStrom 将 es6 编译成 es5 的时候出现了一些问题😭，经过一番搜索， 最后终于成功解决，这里记录一下🖊方法首先建立一个新的工程，点击设置在设置里面，把JavaScript language version改成ECMAScript 6然后在js文件里写一段ES6代码现在IDE会出现一个File watcher提示条此时先别点Add watcher！在终端切换到项目的路径，输入以下命令1npm init -y //package.json安装babel-cli1npm install --save-dev babel-cli现在可以去点Add watcher，点完之后会弹出一个框下面第三行，Program 那一项，填1$ProjectFileDir$/node_modules/.bin/babel然后点OK，这个时候你就会发现左边多出来一个新文件但是现在还没搞定！现在只是搞定了自动转换的功能，系统默认把ES6 编译成了ES6…打开终端，输入：1npm install --save-dev babel-preset-es2015再次打开设置，在搜索框输入file watchers，点击babel在 Arguments 里面将 env 改为 =es2015,点击ok在根目录下新建一个.babelrc文件（就是babel在当前项目的配置文件），写上：12345&#123; "presets": [ "es2015" ]&#125;完成😁]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[解决安装electron卡在node install.js 不动问题]]></title>
      <url>%2F%E8%A7%A3%E5%86%B3%E5%AE%89%E8%A3%85electron%E5%8D%A1%E5%9C%A8node-install-js-%E4%B8%8D%E5%8A%A8%E9%97%AE%E9%A2%98.html</url>
      <content type="text"><![CDATA[在安装electron的时候，一直卡在node install.js不动😭，翻了墙也不行，于是在 github 上搜索终于找到解决方法，为此记录下来📝说明install.js,里面的下载是依赖于electron-download这个模块搜索electron-download发现：👇解决方法打开终端，输入vi ~/.npmrc,在里面添加1electron_mirror="https://npm.taobao.org/mirrors/electron/"再试一次npm install electron -g,这次就成功了😄]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[vscode 前端插件推荐]]></title>
      <url>%2Fvscode-%E5%89%8D%E7%AB%AF%E6%8F%92%E4%BB%B6%E6%8E%A8%E8%8D%90.html</url>
      <content type="text"><![CDATA[常用插件Auto Close Tag自动添加HTML / XML关闭标签（必备）Auto Rename Tag自动重命名配对的HTML / XML标签(必备)Beautify格式化javascript，JSON，CSS，Sass，和HTMLBootstrap 4 &amp; Font awesome snippets包含Bootstrap 4＆Font awesome 的代码片段Bracket Pair Colorizer颜色识别匹配括号Class autocomplete for HTML智能提示HTML class =“”属性（必备）Code Runner非常强大的一款插件，能够运行多种语言的代码片段或代码文件：C，C ++，Java，JavaScript，PHP，Python，Perl，Ruby，Go等等，安装完成后，右上角出现：点击这个按钮就可以运行你的文件了（必备）css peek能够查看CSS ID和类的字符串作为HTML文件中相应的CSS定义（必备）使用方法：将光标放在class里面的属性，右击Dash查文档必备，搭配 dash（不过似乎只有 mac 版）😁快捷键 ctrl + h 它根据你当前选中的语言查找 dash 里面的文档Debugger for Chrome让 vscode 映射 chrome 的 debug功能，使静态页面都可以用 vscode 来打断点调试简单使用：戳我Document This添加注释块设置：123"docthis.includeAuthorTag": true,//出现@Author"docthis.includeDescriptionTag": true,//出现@Description"docthis.authorName": "shenzekun",//作者名字快捷键： 按两次Ctrl+alt+dESLintEsLint可以帮助我们检查Javascript编程时的语法错误。比如：在Javascript应用中，你很难找到你漏泄的变量或者方法。EsLint能够帮助我们分析JS代码，找到bug并确保一定程度的JS语法书写的正确性。配置：戳我Font-awesome codes for html用于 html 的Font-awesome代码片段filesize在底部状态栏显示当前文件大小，点击后还可以看到详细创建、修改时间Git History以图表的形式查看git日志使用 command+shift+p（Ctrl+shift+p） 输入git log就可以看到了Git Lensgit 日志插件HTML CSS Support在 html 标签上写class 智能提示当前项目所支持的样式（必备）HTML Snippetshtml 代码片段（必备）htmlhinthtml代码检测htmltagwrap可以在选中HTML标签中外面套一层标签使用：选择一大段代码，然后按“Alt + W”Indenticator突出目前的缩进深度IntelliSense for CSS class names智能提示 css 的 class 名Image Preview鼠标移到路径里显示图像预览JavaScript (ES6) code snippetses6代码片段（必备）JavaScript Snippet Packjs代码片段（必备）jQuery Code SnippetsjQuery 代码片段Live Sass Compiler实时编译 sass ,不过需要配置，附上我的配置12345678"liveSassCompile.settings.formats":[ // You can add more &#123; "format": "compressed",//压缩 "extensionName": ".min.css",//编译后缀名 "savePath": "./css"//编译保存的路径 &#125; ],使用markdownlintmarkdown 语法检查Node.js Modules Intellisense可以在导入语句中自动完成JavaScript / TypeScript模块。npm Intellisense在导入语句中自动填充npm模块,跟Node.js Modules Intellisense差不多open in browser当前的 html 文件用浏览器打开，类似 webstorm 的那四个小浏览器图标功能，前提条件html 文件必须保存快捷键alt+bOutput Colorizer输出提示的文字颜色有一些变化，方便获取关键信息Path Intellisense路径自动补全（必备）Prettier格式化JavaScript / TypeScript / CSS 。Project Manager工程项目过多时，shift+cmd+p(shift+ctrl+p) 然后输入project，第一次选择edit Project编辑自己的工程项目，之后就可以直接选择open打开你的项目Sass写 sass 必备vscode-faker生成假数据，地址，电话，图片等等打开方式shift+cmd+p(shift+ctrl+p)) 然后输入faker 就可以选择了Quokka.js实时观看 javascript 的变量的变化使用：先shift+cmd+p （ctrl+shift+p）输入 quokka 选择 new javascript 就行了😀Regex Previewer测试正则的插件TSLint检查typescript编程时的语法错误语法TypeScript Importer自动搜索工作区文件中的TypeScript定义，并将所有已知符号作为完成项，以允许代码完成。vscode-icons目录树图标reactReact-Native/React/Redux snippets for es6/es7react代码片段，下载人数超多😉react-beautify格式化 javascript, JSX, typescript, TSX 文件vuevetur语法高亮、智能感知VueHelpervue代码片段Vue TypeScript Snippetsvue的 typescript 代码片段Vue 2 Snippetsvue 2代码片段主题Dracula Official个人最喜欢的主题，应该是最好看的主题之一😀One Dark Pro这个也好看😄Atom One Dark Theme(老版本)这个和 One Dark Pro差不多，One Dark Pro颜色主题多一些One Monokai ThemeEva Theme里面包含黑色和白色主题，这个白色主题感觉挺好看的Boxy Theme Kit大家还有什么好的插件推荐吗🤓]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[js 的 call 与 apply 速度对比]]></title>
      <url>%2Fjs-%E7%9A%84-call-%E4%B8%8E-apply-%E9%80%9F%E5%BA%A6%E5%AF%B9%E6%AF%94.html</url>
      <content type="text"><![CDATA[最近在看 underscore 的源码时发现，作者好多都用 call，而用 apply 比较少，比如说下面这段：👇1234567891011121314151617181920212223242526var optimizeCb = function(func, context, argCount) &#123; // 如果没有指定 this 指向，则返回原函数 if (context === void 0) return func; switch (argCount == null ? 3 : argCount) &#123; case 1: return function(value) &#123; return func.call(context, value); &#125;; case 2: return function(value, other) &#123; return func.call(context, value, other); &#125;; // 如果有指定 this，但没有传入 argCount 参数 // 则执行以下 case case 3: return function(value, index, collection) &#123; return func.call(context, value, index, collection); &#125;; case 4: return function(accumulator, value, index, collection) &#123; return func.call(context, accumulator, value, index, collection); &#125;; &#125;&#125;;既然 call 和 apply 都能用，那为什么只用 call 而不用 apply 呢？经过网上的搜索发现，call 比 apply 速度快，在 console运行如下代码：12345678910111213function x(a,b) &#123;&#125;var a = [1, 2, 3];console.time("call");for (var i = 0; i &lt; 1000000; i++) &#123; x.call(this, 1, 2, 3);&#125;console.timeEnd("call");console.time("apply");for (var j = 0; j &lt; 1000000; j++) &#123; x.apply(this, a);&#125;console.timeEnd("apply");console的结果：可以发现 call 比 apply 快了10ms 左右，那是什么原因造成这样的呢？因为 apply 运行前要对作为参数的数组进行一系列检验和深拷贝，而 call 则没有我们看一下 ECMAScript 是怎么写的：由ECMAScript 标准发现 apply 比 call 的步骤多了好多，这就是 call 比 apply 执行速度快的原因！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Vimium 常用快捷键]]></title>
      <url>%2FVimium-%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE.html</url>
      <content type="text"><![CDATA[最近用了谷歌插件vimium，发现非常好用，牛逼神器一个😄，下面记一下常用的快捷键打开 vimium help 快捷键 shift+/j: 向下移动k: 向上移动h: 左移l : 右移d:向下移动一个页面u:向上移动一个页面gg : 移到页面顶部G : 移到页面底部x:关闭当前标签页X:恢复关闭的标签页H:回到上一个历史页面L:回到下一个历史页面J：跳到左边标签页K：跳到右边标签页r : 刷新gs : 查看网页源码yy : 复制当前页面的 url 到剪切板f: 在当前标签页中打开页面有的链接F:在新标签页中页面有的链接p:在当前标签页中打开剪切板中的链接P:在新的标签页中打开剪切板中的链接t:创建新的标签页(也就是 command+t)T：搜索打开的标签页b : 打开书签B : 在新标签中打开书签/ :查找(相当于 command+f)i : 进入输入模式(这个不知道要干嘛的( ⊙o⊙?))esc：退出输入模式o : 在当前页面中打开URL，书签和历史记录O : 在新标签页面中打开URL，书签和历史记录gi：将焦点集中到第一个输入框]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[前端学习笔记之观察者模式]]></title>
      <url>%2F%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F.html</url>
      <content type="text"><![CDATA[观察者模式也称”发布-订阅”模式,它的作用就是当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知，自动刷新对象状态举个生活比较常见常见的例子,比如你去面试之后，面试官看你表现不错，最后会跟你要联系方式，以便之后可以联系你。在这角色扮演当中，你就是“订阅者”，面试官就是“发布者”。那么发布订阅模式是咋实现的呢？思路给定一个发布者面试者将联系方式给发布者发布者的一个列表有各种职位(web端的，java 的)，里面记载回调函数以便通知这些面试者最后发布消息的时候，会遍历这个列表的职位的回调函数，告诉面试者面试这个职位是通过还是不通过如果面试者取消了订阅，那么将回调函数和之前的回调函数作对比，如果相等，就将这个面试者的上班通知去掉12345678910111213141516171819202122232425262728293031323334353637383940414243var Event = (function() &#123; var events = &#123;&#125;; //发布者 //subscribe也就是订阅，post 代表面试者要面的职位，callback表示为回调函数 function subscribe(post, callback) &#123; events[post] = events[post] || []; //发布者的列表里有没有这个面试职位，如果没有就创建一个空数组 events[post].push(callback); &#125; //publish 表示发布 function publish() &#123; var post = Array.prototype.shift.call(arguments); //第一个参数指定“键” var fns = events[post]; //设置缓存，提高性能 if (!fns) &#123; //如果发布者的列表里没有这个职位，那肯定是不能发布 return; &#125; for (var i = 0; i &lt; fns.length; i++) &#123; //遍历当前的职位的数组里有几个面试者 fns[i].apply(this, arguments); &#125; &#125; //unsubscribe 表示取消订阅 function unsubscribe(post, fn) &#123; var fns = events[post]; if (fns) &#123; if (fn) &#123; for (var i = fns.length; i &gt;= 0; i--) &#123; if (fns[i] === fn) fns.splice(i, 1); &#125; &#125; else &#123;//如果没有传入fn回调函数，直接取消post对应消息的所有订阅 fns = []; &#125; &#125; else &#123;//如果发布者的列表没有这个职位，直接 return return; &#125; &#125; return &#123; subscribe: subscribe, publish: publish, unsubscribe: unsubscribe &#125;;&#125;)();测试：12345678910111213141516171819202122232425var fn1 = function(time) &#123; console.log("小明你通过了面试，上班时间：" + time);&#125;;var fn2 = function(time) &#123; console.log("小强你通过了面试，上班时间：" + time);&#125;;//小明将联系方式给了发布者，发布者（hr）觉得小明不错，可以通过，于是在列表(java)里写下了一些回调函数，到时候发布的时候将上班时间告诉小明Event.subscribe("java", fn1);//小强也订阅了Event.subscribe("java", fn2);Event.publish("java", "2017-10-01");/*输出:小明你通过了面试，上班时间：2017-10-01小强你通过了面试，上班时间：2017-10-01*/Event.unsubscribe("java", fn1);//删除小明的上班通知Event.publish("java", "2017-10-01");/*输出：小强你通过了面试，上班时间：2017-10-01*/参考Javascript异步编程的4种方法js设计模式笔记 - 观察者模式]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[react使用总结]]></title>
      <url>%2Freact-%E4%BD%BF%E7%94%A8-%E6%80%BB%E7%BB%93.html</url>
      <content type="text"><![CDATA[最近学了一些 react 和es6 的一些知识，并且使用 react 写了一个 TodoList 项目===&gt;预览 &amp;&amp; 源码 感觉学的挺多的，并且遇到的坑也不少😂，说实话，一开始学 react 看到 jsx 语法有点不适应，说好的结构和行为分离呢😁，不过随着通过一个项目的完成，渐渐明白了这么写的好处好处自定义标签结构清晰代码模块化更加语义化不过也有缺点浏览器不支持这语法必须通过一大堆工具来转换一些需要注意的点1. react声明组件时，组件名称必须以大写字母开头如👉：&lt;Todo /&gt;2. 每个标签必须闭合,因为采用的 js+xml 写法，如👉: &lt;input /&gt;3. 组件的返回值只能有一个顶层元素，如👇：下面是错误的：123456render () &#123; return ( &lt;div&gt;1&lt;/div&gt; &lt;div&gt;2&lt;/div&gt; )&#125;必须这样12345678render () &#123; return ( &lt;div&gt; &lt;div&gt;1&lt;/div&gt; &lt;div&gt;2&lt;/div&gt; &lt;/div&gt; )&#125;4. return后面要加一个括号,目的是防止 JavaScript 代码在解析时自动在换行处添加分号:12345 renderSquare(i) &#123; return ( &lt;Todo /&gt; );&#125;5. render()里面不能写 class,for,而是要写成className和htmlFor,因为 class ，for 是 javascript 的关键字，因此不能使用，如：下面是错误的1&lt;div class=“xxx”&gt;而是要写 className：1&lt;div className="xxx"&gt;6. 不要直接更新状态，如1this.state.comment = 'Hello';此代码不会重新渲染组件的，之前就这么写，啥反应也没有😂，应该要用setState():👇1this.setState(&#123;comment: 'Hello'&#125;);（注意！！：构造函数（constructor）是唯一能够初始化 this.state 的地方。）7. 使用style我们在 html 可以这么写：1&lt;div style="background-color:red;"&gt;&lt;/div&gt;但是在 jsx 里面却不能这么写，必须用两个花括号包裹，并且里面不能写-，要用驼峰形式写，如上面的 background-color写成backgroundColor:1&lt;div style=&#123;&#123;backgroundColor: 'red'&#125;&#125;&gt;&lt;/div&gt;8. 关于 setStatesetState方法用于更新当前组件的state状态值，但调用这个方法后，state并不会立即更新，而是在render方法调用后才会更新react 特点虚拟DOM: React是以数据驱动的，每次数据变化React都会扫描整个虚拟DOM树，自动计算与上次虚拟DOM的差异变化，然后针对需要变化的部分进行实际的浏览器DOM更新。组件化： React可以从功能角度划分，将UI分解成不同组件，各组件都独立封装，整个UI是由一个个小组件构成的一个大组件，每个组件只关系自身的逻辑，彼此独立（比如你有个按钮，很多页面都有这个按钮，那么就可以把这个按钮封装成该组件）。单项数据流：React只有单向数据流动-从父节点传递到子节点]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[解决 webstrom sass 注释中文出错问题]]></title>
      <url>%2F%E8%A7%A3%E5%86%B3-webstrom-sass-%E6%B3%A8%E9%87%8A%E4%B8%AD%E6%96%87%E5%87%BA%E9%94%99%E9%97%AE%E9%A2%98.html</url>
      <content type="text"><![CDATA[最近用 webStrom 写 sass，感觉非常好用，自动帮你编译好，但是有一个问题，就是在写中文注释的时候，就会出错如下：网上查了一下，说在 scss 文件头部加上：1@charset "utf-8";但是，我试了一下并不管用！！😂经过一番查找终于找到方法，在这里记录一下：① 在 scss 文件的头部加上：1@charset "utf-8";② 打开/Library/Ruby/Gems/2.0.0/gems/sass-3.4.22/lib/sass/engine.rb(mac)在 require 后面加上：1Encoding.default_external = Encoding.find('utf-8')如下：现在就可以支持中文注释了😀]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[前端小项目之在线便利贴]]></title>
      <url>%2F%E5%89%8D%E7%AB%AF%E5%B0%8F%E9%A1%B9%E7%9B%AE%E4%B9%8B%E5%9C%A8%E7%BA%BF%E4%BE%BF%E5%88%A9%E8%B4%B4.html</url>
      <content type="text"><![CDATA[实现的效果如下：界面可能不是太好看😁，考虑到容器的高度会被拉长，因此没有用图片做背景。预览便利贴涉及的知识点sass(css 预编译器)webpack（自动化构建工具，实现LESS,CSS,JS编译和压缩代码）express (基于 Node.js 平台的 web 开发框架)html+cssNode.js(基于 Chrome V8 引擎的 JavaScript 运行环境)jQuery(一个快速、简洁的JavaScript框架)sequelize(Node的ORM框架Sequelize操作数据库)passport(实现第三方登录)实现功能github第三方登录添加笔记（登录成功后）删除笔记修改笔记使用 markdown(类似 typroa)笔记拖拽准备工作必要条件：已经安装好了node环境,还没安装的可以去node中文官网下载小提示：如果用 npm 下载感觉慢的话，可以下载一个切换镜像源的工具nrm,在终端输入：1npm i nrm -g然后如下操作：开始！！1.新建一个文件夹，名字自己起，打开终端，切换到自己新建文件夹，如：1cd (文件夹名称)2.生成 package.json1npm init -y3.安装 express1npm i express --save4.安装 express生成器:1npm install express-generator --save5.生成 ejs 模板（类似 jsp 的写法）12express -f -enpm i其中public用来存放编译后的js文件以及编译好的css文件等，routes用来存放处理 ajax 的请求文件，views就是存放视图文件然后新建 database 和 src：其中 src/js 里面 app 代表不同页面的入口文件，lib 就是一些常用的库，mod 就是你写的一些模块，database 用来存放数据库数据的6.输入：1npm start如果有出现下面的错误：出现这个错误是因为你没有下载模块，只需在终端输入：1npm i (模块名) --save就可以了7.打开浏览器，输入localhost:3000出现下面这样就说明成功了：8.接下来安装webpack和相关依赖12npm i webpack --save-devnpm i --save css-loader style-loader express-session express-flash node-sass passport sass sass-loader sequelize sqlite3 extract-text-webpack-plugin onchange9.在 src 里建一个 webpack.config.js，配置如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546var webpack = require('webpack');var path = require('path');var ExtractTextPlugin = require('extract-text-webpack-plugin')var autoprefixer = require('autoprefixer'); module.exports = &#123; entry: path.join(__dirname, "js/app/index"), output: &#123; path: path.join(__dirname, "../public"), filename: "js/index.js" &#125;, module: &#123; rules: [&#123; test: /(\.scss)$/, use: ExtractTextPlugin.extract(&#123; fallback: "style-loader", use: ["css-loader", "sass-loader"] &#125;) //把 css 抽离出来生成一个文件 &#125;] &#125;, resolve: &#123; alias: &#123; jquery: path.join(__dirname, "js/lib/jquery-2.0.3.min.js"), mod: path.join(__dirname, "js/mod"), sass: path.join(__dirname, "sass") &#125; &#125;, plugins: [ new webpack.ProvidePlugin(&#123; $: "jquery" &#125;), new ExtractTextPlugin("css/index.css"), new webpack.LoaderOptionsPlugin(&#123; options: &#123; css: [ autoprefixer(), ] &#125; &#125;), new webpack.optimize.UglifyJsPlugin(&#123; compress: &#123; warnings: false &#125; &#125;) ]&#125;说明entry:入口文件，也就是 src/js/app里面的index.js,其中__dirname是获得当前文件所在目录的完整目录名output:输出编译后的文件 index.js，输出到 public/js 里面module：配置Loaders，通过使用不同的loader，webpack有能力调用外部的脚本或工具，实现对不同格式的文件的处理，比如说分析转换scss为css，或者把下一代的JS文件resolve.alias：设置模块别名，便于我们更方便引用，比如说我在 js里面的文件需要 jquery，在里面的文件直接写 require(“jquery”) 就行了如果所有文件都需要 jquery,那么直接在 plugins里面写成这样：就不需要 require 了这个是压缩文件的10.在 package.json 中，增加如下两条：写成这样，你在终端就可以写成npm run webpack 来编译文件，npm run watch来监控 src 里面的 js 和 scss 的变化，只要一修改，进行编译，提高了效率11.测试你可以试试在 js 里面的 index.js写点东西，然后 npm run webpack，如果终端显示是这样：就证明成功了项目思路逻辑比较简单首先用户必须登录才能添加笔记，当用户失焦的时候，将数据插入数据库，并且重新布局（瀑布流）用户不能更改其他用户的笔记，除了管理员😄用户更新笔记之后，数据库的数据重新更新，重新布局用户可以删除笔记，数据从数据库中删除，重新布局用户可以拖拽笔记，但不将位置存入数据库实现html,css就不讲了，可以看看我的源码,主要讲 js。1.瀑布流的实现思路：（前提是必须绝对定位）获取元素的宽度通过窗口的宽度除以元素的宽度来获取列数初始化一个数组来获取每列的高度，初始化每列的高度为0遍历元素，获取最小的的列数的高度和索引，对当前元素进行定位，列数高度加等于当前元素的高度知道思路后，代码很快就写出来了：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647var WaterFall = (function () &#123; var $ct, $items; function render($c) &#123; $ct = $c; $items = $ct.children(); var nodeWidth = $items.outerWidth(true), windowHeight = $(window).height(), colNum = parseInt($(window).width() / nodeWidth), //获取列数 colSumHeight = []; //获取每列的高度 //对每列的高度进行初始化 for (var i = 0; i &lt; colNum; i++) &#123; colSumHeight[i] = 0; &#125; $items.each(function () &#123; var $current = $(this); var index = 0, minSumHeight = colSumHeight[0]; //获取最小的的列数的高度和索引 for (var i = 0; i &lt; colSumHeight.length; i++) &#123; if (minSumHeight &gt; colSumHeight[i]) &#123; index = i; minSumHeight = colSumHeight[i]; &#125; &#125; //改变窗口高度 if (windowHeight &lt; minSumHeight) &#123; $("body").height(minSumHeight); &#125; else &#123; $("body").height(windowHeight - 72); &#125; //对当前元素进行定位 $current.animate(&#123; left: nodeWidth * index, top: minSumHeight &#125;, 5); colSumHeight[index] += $current.outerHeight(true); &#125;); &#125; //当窗口发生变化时，重新渲染 $(window).on('resize', function () &#123; render($ct); &#125;); return &#123; init: render &#125; &#125;)();2.笔记的拖拽我们先看个图因此代码如下：12345678910111213141516171819//设置笔记的移动 $noteHead.on('mousedown', function (e) &#123; var evtX = e.pageX - $note.offset().left, //evtX 计算事件的触发点在 dialog内部到 dialog 的左边缘的距离 evtY = e.pageY - $note.offset().top; $note.addClass('draggable').data('evtPos', &#123; x: evtX, y: evtY &#125;); //把事件到 dialog 边缘的距离保存下来 &#125;).on('mouseup', function () &#123; $note.removeClass('draggable').removeData('pos'); &#125;); $('body').on('mousemove', function (e) &#123; $('.draggable').length &amp;&amp; $('.draggable').offset(&#123; top: e.pageY - $('.draggable').data('evtPos').y, // 当用户鼠标移动时，根据鼠标的位置和前面保存的距离，计算 dialog 的绝对位置 left: e.pageX - $('.draggable').data('evtPos').x &#125;); &#125;); &#125;,3.提示模块这个比较容易：123456789101112131415161718192021222324252627282930313233343536373839/* 提示模块参数：状态(1表示成功，0表示失败)，消息，出现时间(不写默认是1s) */function toast(status, msg, time) &#123; this.status = status; this.msg = msg; this.time = time || 1000; this.createToast(); this.showToast();&#125;toast.prototype = &#123; createToast: function () &#123; if (this.status === 1) &#123; var html = '&lt;div class="toast"&gt;&lt;img src="../../imgs/1.png" class="toast_icon"&gt;&lt;/img&gt;&lt;span class="toast_word"&gt;' + this.msg + '&lt;/span&gt;&lt;/div&gt;'; this.$toast = $(html); $('body').append(this.$toast); &#125; else &#123; var html = '&lt;div class="toast"&gt;&lt;img src="../../imgs/0.png" class="toast_icon"&gt;&lt;/img&gt;&lt;span class="toast_word"&gt;' + this.msg + '&lt;/span&gt;&lt;/div&gt;'; this.$toast = $(html); $('body').append(this.$toast); &#125; &#125;, showToast: function () &#123; var _this = this; this.$toast.fadeIn(300, function () &#123; setTimeout(function () &#123; _this.$toast.fadeOut(300, function () &#123; _this.$toast.remove(); &#125;); &#125;, _this.time); &#125;) &#125;&#125;function Toast(status, msg, time) &#123; return new toast(status, msg, time);&#125;4.笔记模块思路：初始化（如 id，username 等等）创建节点设置颜色绑定事件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156function Note(opts) &#123; this.initOpts(opts); this.createNode(); this.setColor(); this.bind();&#125;Note.prototype = &#123; colors: [ ['#ea9b35', '#efb04e'], // headColor, containerColor ['#dd598b', '#e672a2'], ['#c24226', '#d15a39'], ['#c1c341', '#d0d25c'], ['#3f78c3', '#5591d2'] ], defaultOpts: &#123; id: '', //Note的 id $ct: $('#content').length &gt; 0 ? $('#content') : $('body'), //默认存放 Note 的容器 context: '请输入内容', //Note 的内容 createTime: new Date().toLocaleDateString().replace(/\//g, '-').match(/^\d&#123;4&#125;-\d&#123;1,2&#125;-\d&#123;1,2&#125;/), username: 'admin' &#125;, initOpts: function (opts) &#123; this.opts = $.extend(&#123;&#125;, this.defaultOpts, opts || &#123;&#125;); if (this.opts.id) &#123; this.id = this.opts.id; &#125; this.createTime = this.opts.createTime ? this.opts.createTime : new Date().toLocaleDateString().replace(/\//g, '-').match(/^\d&#123;4&#125;-\d&#123;1,2&#125;-\d&#123;1,2&#125;/); this.username = this.opts.username ? this.opts.username : 'admin' &#125;, createNode: function () &#123; var tpl = '&lt;div class="note"&gt;' + '&lt;div class="note-head"&gt;&lt;span class="delete"&gt;&amp;times;&lt;/span&gt;&lt;/div&gt;' + '&lt;div class="note-ct" contenteditable="true"&gt;&lt;/div&gt;' + '&lt;div class="note-info"&gt;&lt;div class="note-name"&gt;' + this.username + '&lt;/div&gt;&lt;div class="note-time"&gt;' + this.createTime + '&lt;/div&gt;' + '&lt;/div&gt;'; this.$note = $(tpl); this.$note.find('.note-ct').html(this.opts.context); this.opts.$ct.append(this.$note); //if (!this.id) this.$note.css('bottom', '10px'); //新增放到右边 Event.fire('waterfall'); &#125;, setColor: function () &#123; var color = this.colors[Math.floor(Math.random() * 5)]; this.$note.find(".note-head").css('background-color', color[0]); this.$note.find('.note-ct').css('background-color', color[1]); this.$note.find('.note-info').css('background-color', color[1]); &#125;, setLayout: function () &#123; var self = this; if (self.clock) &#123; clearTimeout(self.clock); &#125; self.clock = setTimeout(function () &#123; Event.fire('waterfall'); &#125;, 100); &#125;, bind: function () &#123; var _this = this, //记录下坑，之前末尾是分号不是逗号后面都变成了全局变量结果造成了最后一个才能修改😂 $note = this.$note, $noteHead = $note.find('.note-head'), $noteCt = $note.find('.note-ct'), $close = $note.find('.delete'); $close.on('click', function () &#123; _this.delete(); &#125;); $noteCt.on('focus', function () &#123; if ($noteCt.html() === '请输入内容') $noteCt.html(''); $noteCt.data('before', $noteCt.html()); &#125;).on('blur paste', function () &#123; if ($noteCt.data('before') != $noteCt.html()) &#123; $noteCt.data('before', $noteCt.html()); _this.setLayout(); if (_this.id) &#123; //判断是否有这个id，如果有就更新，如果没有就添加 _this.edit($noteCt.html()) &#125; else &#123; _this.add($noteCt.html()) &#125; &#125; &#125;); //设置笔记的移动 $noteHead.on('mousedown', function (e) &#123; var evtX = e.pageX - $note.offset().left, //evtX 计算事件的触发点在 dialog内部到 dialog 的左边缘的距离 evtY = e.pageY - $note.offset().top; $note.addClass('draggable').data('evtPos', &#123; x: evtX, y: evtY &#125;); //把事件到 dialog 边缘的距离保存下来 &#125;).on('mouseup', function () &#123; $note.removeClass('draggable').removeData('pos'); &#125;); $('body').on('mousemove', function (e) &#123; $('.draggable').length &amp;&amp; $('.draggable').offset(&#123; top: e.pageY - $('.draggable').data('evtPos').y, // 当用户鼠标移动时，根据鼠标的位置和前面保存的距离，计算 dialog 的绝对位置 left: e.pageX - $('.draggable').data('evtPos').x &#125;); &#125;); &#125;, /* 添加笔记到数据库 */ add: function (msg) &#123; var _this = this; $.post('/api/notes/add', &#123; note: msg &#125;).done(function (res) &#123; if (res.status === 1) &#123; _this.id = res.id; Toast(1, '添加成功！'); &#125; else &#123; _this.$note.remove(); Event.fire('waterfall'); Toast(0, res.errorMsg); &#125; &#125;) &#125;, /* 编辑笔记数据库 */ edit: function (msg) &#123; var _this = this; $.post('/api/notes/edit', &#123; id: this.id, note: msg &#125;).done(function (res) &#123; if (res.status === 1) &#123; Toast(1, '更新成功！'); &#125; else &#123; Toast(0, res.errorMsg); &#125; &#125;); &#125;, /* 删除笔记 */ delete: function () &#123; var _this = this; if (confirm("确认要删除吗？")) &#123; $.post('/api/notes/delete', &#123; id: this.id &#125;).done(function (res) &#123; if (res.status === 1) &#123; Toast(1, '删除成功！'); _this.$note.remove(); Event.fire('waterfall') &#125; else &#123; Toast(0, res.errorMsg); &#125; &#125;); &#125; &#125;&#125;5.笔记管理模块1234567891011121314151617181920212223242526272829303132333435363738394041var NoteManager = (function () &#123; //页面加载 function load() &#123; $.get('api/notes').done(function (res) &#123; if (res.status === 1) &#123; $.each(res.data, function (index, msg) &#123; new Note(&#123; id: msg.id, context: msg.text, createTime: msg.createdAt.match(/^\d&#123;4&#125;-\d&#123;1,2&#125;-\d&#123;1,2&#125;/), username: msg.username &#125;); &#125;); Event.fire('waterfall'); &#125; else &#123; Toast(0, res.errorMsg); &#125; &#125;).fail(function () &#123; Toast(0, "网络异常"); &#125;); &#125; /* 添加笔记 */ function add() &#123; $.get('/login').then(function (res) &#123;//判断是否登录 if (res.status === 1) &#123; new Note(&#123; username: res.username &#125;); &#125; else &#123; Toast(0, res.errorMsg); &#125; &#125;); &#125; return &#123; load: load, add: add &#125;&#125;)();6.发布订阅模式1234567891011121314151617181920212223242526272829/* 发布订阅模式 */var Event = (function () &#123; var events = &#123;&#125;; function on(evt, handler) &#123; events[evt] = events[evt] || []; events[evt].push(&#123; handler: handler &#125;); &#125; function fire(evt, args) &#123; if (!events[evt]) &#123; return; &#125; for (var i = 0; i &lt; events[evt].length; i++) &#123; events[evt][i].handler(args); &#125; &#125; function off(name) &#123; delete events[name]; &#125; return &#123; on: on, fire: fire, off: off &#125;&#125;)();写完模块后，写入口文件index.js123456789101112131415require('sass/index.scss');var Toast = require('mod/toast.js').Toast;var WaterFall = require('mod/waterfall.js');var NoteManager = require('mod/note-manager');var Event = require('mod/event.js');NoteManager.load();$('.add-note').on('click', function () &#123; NoteManager.add();&#125;)Event.on('waterfall', function () &#123; WaterFall.init($("#content"));&#125;)到这就差不多完成了70%了，接下来就创建数据库，连接数据库了123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/*创建数据库 运行 node note.js*/var Sequelize = require('sequelize');var path = require('path');var sequelize = new Sequelize(undefined, undefined, undefined, &#123; host: 'localhost', dialect: 'sqlite', // SQLite only storage: path.join(__dirname, '../database/database.sqlite')&#125;);/* 测试连接是否成功node note.jssequelize.authenticate() .then(() =&gt; &#123; console.log('Connection has been established successfully.'); &#125;) .catch(err =&gt; &#123; console.error('Unable to connect to the database:', err); &#125;);*/var Note = sequelize.define('note', &#123; text: &#123; type: Sequelize.STRING &#125;, userid: &#123; type: Sequelize.INTEGER &#125;, username: &#123; type: Sequelize.STRING &#125;&#125;);Note.sync();/*删除表Note.drop();*//*//创建数据库Note.sync().then(function()&#123; Note.create(&#123;text:"sdsdsdsd"&#125;);&#125;).then(function()&#123; //查询表 Note.findAll(&#123;raw:true&#125;).then(function(notes)&#123; console.log(notes); &#125;)&#125;);*/module.exports = Note;然后是在routes 里处理 ajax 请求，处理登录信息，获取 id，用户名等等，到这就基本完成了总结经过一星期的开发，了解了前后端联调，模块化开发方式、webpack 及loader和插件的使用、npm 的使用，Express的使用、路由、中间件、sqlite3、nodejs，在开发过程中还是有遇到许多问题，例如在连续声明变量的时候，不小心把逗号写成了分号，其他变量就变成了全局变量，于是就出错了，查了好久😂不过在这过程之中还是学到了许多，重要的是过程，继续往前端的路走下去😄]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[解决inline-block元素的bug]]></title>
      <url>%2F%E8%A7%A3%E5%86%B3inline-block%E5%85%83%E7%B4%A0%E7%9A%84bug.html</url>
      <content type="text"><![CDATA[在使用inline-block时，有时候出现的效果莫名奇妙，例如：两个inline-block 元素之间如果有空格、回车、tab，那么在页面上就有一个空隙两个不同高度的 inline-block 元素顶部无法对齐，或者使用inline-block下面无缘无故多出几像素例子1,出现空隙12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;JS Bin&lt;/title&gt; &lt;style&gt; div&#123; display: inline-block; width:100px; height: 100px; background-color: rgb(233, 148, 148); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;效果：解决方法1.去掉空格123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;JS Bin&lt;/title&gt; &lt;style&gt; div&#123; display: inline-block; width:100px; height: 100px; background-color: rgb(233, 148, 148); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;2. 添加父元素，将父元素的 font-size 设置为0，然后在 inline-block 元素中将 font-size 设置为 14px12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;JS Bin&lt;/title&gt; &lt;style&gt; .parent&#123; font-size:0; &#125; .child&#123; font-size:14px; display: inline-block; width:100px; height: 100px; background-color: rgb(233, 148, 148); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="parent"&gt; &lt;div class="child"&gt;&lt;/div&gt; &lt;div class="child"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;3. 使用margin-right1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;JS Bin&lt;/title&gt; &lt;style&gt; .child&#123; display: inline-block; width:100px; height: 100px; background-color: rgb(233, 148, 148); margin-right:-5px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="child"&gt;&lt;/div&gt; &lt;div class="child"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;4. 添加父元素，使用letter-spacing（该属性增加或减少字符间的空白（字符间距））123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;JS Bin&lt;/title&gt; &lt;style&gt; .parent&#123; letter-spacing:-5px; &#125; .child&#123; display: inline-block; width:100px; height: 100px; background-color: rgb(233, 148, 148); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="parent"&gt; &lt;div class="child"&gt;&lt;/div&gt; &lt;div class="child"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;5. 使用word-spacing （该属性增加或减少单词间的空白（即字间隔））123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;JS Bin&lt;/title&gt; &lt;style&gt; .parent&#123; word-spacing:-5px; &#125; .child&#123; display: inline-block; width:100px; height: 100px; background-color: rgb(233, 148, 148); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="parent"&gt; &lt;div class="child"&gt;&lt;/div&gt; &lt;div class="child"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;解决效果：例子2，设置inline-block 后，莫名其妙出现一些空白12345678910111213141516171819202122232425262728&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;span设为inline-block之后下面的空白&lt;/title&gt; &lt;style&gt; div&#123; border:solid 1px rgb(202, 43, 43); width:250px; &#125; span&#123; display:inline-block; width:200px; height:200px; background-color:rgb(109, 195, 252); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;span&gt;&lt;/span&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;效果解决方法使用vertical-align12345678910111213141516171819202122232425262728&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;span设为inline-block之后下面的空白&lt;/title&gt; &lt;style&gt; div&#123; border:solid 1px rgb(202, 43, 43); width:250px; &#125; span&#123; display:inline-block; width:200px; height:200px; background-color:rgb(109, 195, 252); vertical-align:top;//新增 &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;span&gt;&lt;/span&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;解决效果例子3，两个不同高度的 inline-block 元素顶部无法对齐1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;JS Bin&lt;/title&gt; &lt;style&gt; .child1&#123; display: inline-block; width:100px; height: 100px; background-color: rgb(109, 195, 252); &#125; .child2&#123; display: inline-block; width:100px; height: 120px; background-color: rgb(233, 148, 148); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="child1"&gt;&lt;/div&gt; &lt;div class="child2"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;效果解决方法还是使用vertical-align1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;JS Bin&lt;/title&gt; &lt;style&gt; .child1&#123; display: inline-block; width:100px; height: 100px; vertical-align:top;//新增 background-color: rgb(109, 195, 252); &#125; .child2&#123; display: inline-block; width:100px; height: 120px; background-color: rgb(233, 148, 148); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="child1"&gt;&lt;/div&gt; &lt;div class="child2"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;解决效果]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[浮动]]></title>
      <url>%2F%E6%B5%AE%E5%8A%A8.html</url>
      <content type="text"><![CDATA[最近在学浮动的知识，下面总结了一些浮动的一些特征1. 块级元素浮动将并排显示，不再独占一行示例代码：123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .box2&#123; width: 100px; height: 100px; border: 1px solid #ccc; background-color: skyblue; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box2"&gt;&lt;/div&gt; &lt;div class="box2"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;效果：修改：123456789&lt;style&gt; .box2&#123; width: 100px; height: 100px; border: 1px solid #ccc; background-color: skyblue; float: left;/*新增*/ &#125;&lt;/style&gt;修改效果：2. 内联样式浮动就可以设置宽高，不仅能够支持margin-left(right)，而且也支持margin-top(bottom)示例代码：123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; *&#123; margin: 0; padding: 0; &#125; .box2&#123; width: 20px;/*无效*/ height: 70px;/*无效*/ border: 1px solid #ccc; margin-top: 20px;/*无效*/ padding: 100px 30px; background-color: skyblue; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;span class="box2"&gt;&lt;/span&gt; &lt;span class="box2"&gt;&lt;/span&gt;&lt;/body&gt;&lt;/html&gt;效果：修改：123456789101112131415&lt;style&gt; *&#123; margin: 0; padding: 0; &#125; .box2&#123; width: 20px;/*生效*/ height: 70px;/*生效*/ border: 1px solid #ccc; margin-top: 20px;/*生效*/ padding: 100px 30px; background-color: skyblue; float: left;/*新增*/ &#125;&lt;/style&gt;修改效果：3. 浮动元素脱离正常的文档流,普通元素会占据浮动元素的位置从上图可以看出，默认三个设置了宽高的block元素，本来会格子独占一行；如果框1设置了向左/向右浮动，他会忽略框2和框3，直到碰到父元素；同时也存在盖住普通元素的风险。4. 浮动会导致父元素高度坍塌示例代码：12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div style="border: solid 5px #0e0; width:300px;"&gt; &lt;div style="height: 100px; width: 100px; background-color: Red; float:left;"&gt; &lt;/div&gt; &lt;div style="height: 100px; width: 100px; background-color: Green; float:left;"&gt; &lt;/div&gt; &lt;div style="height: 100px; width: 100px; background-color: Yellow; float:left;"&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;效果：如上图所示，浮动元素脱离了文档流，并不占据文档流的位置，自然父元素也就不能被撑开，所以没了高度，导致父元素高度坍塌。浮动元素对父元素的影响对父容器 若子元素都是浮动元素，则无法撑开父元素高度，父元素失去高度。浮动元素其他浮动元素的影响对其他浮动元素，如果包含块太窄，无法完全水平容纳浮动元素，那么其他浮动元素就会向下移动，直到有足够空间。如果浮动元素高度不同，那么向下移动时可能会被卡住。示例代码1（块太窄，向下移动）：12345678&lt;div style="border: solid 5px #0e0; width:250px;"&gt; &lt;div style="height: 100px; width: 100px; background-color: Red; float:left;"&gt; &lt;/div&gt; &lt;div style="height: 100px; width: 100px; background-color: Green; float:left;"&gt; &lt;/div&gt; &lt;div style="height: 100px; width: 100px; background-color: Yellow; float:left;"&gt; &lt;/div&gt;&lt;/div&gt;效果：示例代码2（卡住）:12345678&lt;div style="border: solid 5px #0e0; width:250px;"&gt; &lt;div style="height: 120px; width: 100px; background-color: Red; float:left;"&gt; &lt;/div&gt; &lt;div style="height: 100px; width: 100px; background-color: Green; float:left;"&gt; &lt;/div&gt; &lt;div style="height: 100px; width: 100px; background-color: Yellow; float:left;"&gt; &lt;/div&gt;&lt;/div&gt;效果：浮动元素对普通元素的影响普通元素会表现得当作浮动元素不存在一样，浮动元素可以覆盖普通元素，如果宽高合适，普通元素可以占据浮动元素原来的位置对文字的影响文字(既inline-level)级的元素会环绕浮动元素，表现的像是察觉到浮动元素一样。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[hexo的next主题个性化教程:打造炫酷网站]]></title>
      <url>%2Fhexo%E7%9A%84next%E4%B8%BB%E9%A2%98%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B.html</url>
      <content type="text"><![CDATA[看到有些next主题的网站很炫酷，那么是怎么配置的呢？接下来我会讲一讲如何实现一些炫酷的效果主要有以下33种：在右上角或者左上角实现fork me on github添加RSS添加动态背景实现点击出现桃心效果修改文章内链接文本样式修改文章底部的那个带#号的标签在每篇文章末尾统一添加“本文结束”标记修改作者头像并旋转博文压缩修改``代码块自定义样式侧边栏社交小图标设置主页文章添加阴影效果在网站底部加上访问量添加热度网站底部字数统计添加 README.md 文件设置网站的图标Favicon实现统计功能添加顶部加载条在文章底部增加版权信息添加网易云跟帖(跟帖关闭，已失效，改为来必力)隐藏网页底部powered By Hexo / 强力驱动修改网页底部的桃心文章加密访问添加jiathis分享博文置顶修改字体大小修改打赏字体不闪动侧边栏推荐阅读自定义鼠标样式为博客加上萌萌的宠物DaoVoice 在线联系点击爆炸效果1. 在右上角或者左上角实现fork me on github实现效果图具体实现方法点击这里或者这里挑选自己喜欢的样式，并复制代码。 例如，我是复制如下代码：然后粘贴刚才复制的代码到themes/next/layout/_layout.swig文件中(放在&lt;div class=&quot;headband&quot;&gt;&lt;/div&gt;的下面)，并把href改为你的github地址2.添加RSS实现效果图具体实现方法切换到你的blog（我是取名blog，具体的看你们的取名是什么）的路径，例如我是在/Users/chenzekun/Code/Hexo/blog这个路径上，也就是在你的根目录下然后安装 Hexo 插件：(这个插件会放在node_modules这个文件夹里)1$ npm install --save hexo-generator-feed接下来打开画红线的文件，如下图：在里面的末尾添加：(请注意在冒号后面要加一个空格，不然会发生错误！)123# Extensions## Plugins: http://hexo.io/plugins/plugins: hexo-generate-feed然后打开next主题文件夹里面的_config.yml,在里面配置为如下样子：(就是在rss:的后面加上/atom.xml,注意在冒号后面要加一个空格)1234# Set rss to false to disable feed link.# Leave rss as empty to use site's feed link.# Set rss to specific value if you have burned your feed already.rss: /atom.xml配置完之后运行：1$ hexo g重新生成一次，你会在./public 文件夹中看到 atom.xml 文件。然后启动服务器查看是否有效，之后再部署到 Github 中。3. 添加动态背景实现效果图具体实现方法这个我之前有一篇文章有讲过了，详情点击我的博客4. 实现点击出现桃心效果实现效果图具体实现方法在网址输入如下1http://7u2ss1.com1.z0.glb.clouddn.com/love.js然后将里面的代码copy一下，新建love.js文件并且将代码复制进去，然后保存。将love.js文件放到路径/themes/next/source/js/src里面，然后打开\themes\next\layout\_layout.swig文件,在末尾（在前面引用会出现找不到的bug）添加以下代码：12&lt;!-- 页面点击小红心 --&gt;&lt;script type="text/javascript" src="/js/src/love.js"&gt;&lt;/script&gt;5. 修改文章内链接文本样式实现效果图具体实现方法修改文件 themes\next\source\css\_common\components\post\post.styl，在末尾添加如下css样式，：1234567891011// 文章内链接文本样式.post-body p a&#123; color: #0593d3; border-bottom: none; border-bottom: 1px solid #0593d3; &amp;:hover &#123; color: #fc6423; border-bottom: none; border-bottom: 1px solid #fc6423; &#125;&#125;其中选择.post-body 是为了不影响标题，选择 p 是为了不影响首页“阅读全文”的显示样式,颜色可以自己定义。6. 修改文章底部的那个带#号的标签实现效果图具体实现方法修改模板/themes/next/layout/_macro/post.swig，搜索 rel=&quot;tag&quot;&gt;#，将 # 换成&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt;7. 在每篇文章末尾统一添加“本文结束”标记实现效果图具体实现方法在路径 \themes\next\layout\_macro 中新建 passage-end-tag.swig 文件,并添加以下内容：12345&lt;div&gt; &#123;% if not is_index %&#125; &lt;div style="text-align:center;color: #ccc;font-size:14px;"&gt;-------------本文结束&lt;i class="fa fa-paw"&gt;&lt;/i&gt;感谢您的阅读-------------&lt;/div&gt; &#123;% endif %&#125;&lt;/div&gt;接着打开\themes\next\layout\_macro\post.swig文件，在post-body 之后， post-footer 之前添加如下画红色部分代码（post-footer之前两个DIV）：代码如下：12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include 'passage-end-tag.swig' %&#125; &#123;% endif %&#125;&lt;/div&gt;然后打开主题配置文件（_config.yml),在末尾添加：123# 文章末尾添加“本文结束”标记passage_end_tag: enabled: true完成以上设置之后，在每篇文章之后都会添加如上效果图的样子。8. 修改作者头像并旋转实现效果图具体实现方法打开\themes\next\source\css\_common\components\sidebar\sidebar-author.styl，在里面添加如下代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960.site-author-image &#123; display: block; margin: 0 auto; padding: $site-author-image-padding; max-width: $site-author-image-width; height: $site-author-image-height; border: $site-author-image-border-width solid $site-author-image-border-color; /* 头像圆形 */ border-radius: 80px; -webkit-border-radius: 80px; -moz-border-radius: 80px; box-shadow: inset 0 -1px 0 #333sf; /* 设置循环动画 [animation: (play)动画名称 (2s)动画播放时长单位秒或微秒 (ase-out)动画播放的速度曲线为以低速结束 (1s)等待1秒然后开始动画 (1)动画播放次数(infinite为循环播放) ]*/ /* 鼠标经过头像旋转360度 */ -webkit-transition: -webkit-transform 1.0s ease-out; -moz-transition: -moz-transform 1.0s ease-out; transition: transform 1.0s ease-out;&#125;img:hover &#123; /* 鼠标经过停止头像旋转 -webkit-animation-play-state:paused; animation-play-state:paused;*/ /* 鼠标经过头像旋转360度 */ -webkit-transform: rotateZ(360deg); -moz-transform: rotateZ(360deg); transform: rotateZ(360deg);&#125;/* Z 轴旋转动画 */@-webkit-keyframes play &#123; 0% &#123; -webkit-transform: rotateZ(0deg); &#125; 100% &#123; -webkit-transform: rotateZ(-360deg); &#125;&#125;@-moz-keyframes play &#123; 0% &#123; -moz-transform: rotateZ(0deg); &#125; 100% &#123; -moz-transform: rotateZ(-360deg); &#125;&#125;@keyframes play &#123; 0% &#123; transform: rotateZ(0deg); &#125; 100% &#123; transform: rotateZ(-360deg); &#125;&#125;9. 博文压缩在站点的根目录下执行以下命令：12$ npm install gulp -g$ npm install gulp-minify-css gulp-uglify gulp-htmlmin gulp-htmlclean gulp --save在如下图所示，新建 gulpfile.js ，并填入以下内容：123456789101112131415161718192021222324252627282930313233var gulp = require('gulp');var minifycss = require('gulp-minify-css');var uglify = require('gulp-uglify');var htmlmin = require('gulp-htmlmin');var htmlclean = require('gulp-htmlclean');// 压缩 public 目录 cssgulp.task('minify-css', function() &#123; return gulp.src('./public/**/*.css') .pipe(minifycss()) .pipe(gulp.dest('./public'));&#125;);// 压缩 public 目录 htmlgulp.task('minify-html', function() &#123; return gulp.src('./public/**/*.html') .pipe(htmlclean()) .pipe(htmlmin(&#123; removeComments: true, minifyJS: true, minifyCSS: true, minifyURLs: true, &#125;)) .pipe(gulp.dest('./public'))&#125;);// 压缩 public/js 目录 jsgulp.task('minify-js', function() &#123; return gulp.src('./public/**/*.js') .pipe(uglify()) .pipe(gulp.dest('./public'));&#125;);// 执行 gulp 命令时执行的任务gulp.task('default', [ 'minify-html','minify-css','minify-js']);生成博文是执行 hexo g &amp;&amp; gulp 就会根据 gulpfile.js 中的配置，对 public 目录中的静态资源文件进行压缩。10. 修改``代码块自定义样式实现效果图具体实现方法打开\themes\next\source\css\_custom\custom.styl,向里面加入：(颜色可以自己定义)123456789101112131415// Custom styles.code &#123; color: #ff7600; background: #fbf7f8; margin: 2px;&#125;// 大代码块的自定义样式.highlight, pre &#123; margin: 5px 0; padding: 5px; border-radius: 3px;&#125;.highlight, code, pre &#123; border: 1px solid #d6d6d6;&#125;11. 侧边栏社交小图标设置实现效果图具体实现方法打开主题配置文件（_config.yml），搜索social_icons:,在图标库找自己喜欢的小图标，并将名字复制在如下位置，保存即可12. 主页文章添加阴影效果实现效果图具体实现方法打开\themes\next\source\css\_custom\custom.styl,向里面加入：12345678// 主页文章添加阴影效果 .post &#123; margin-top: 60px; margin-bottom: 60px; padding: 25px; -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5); -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5); &#125;13. 在网站底部加上访问量实现效果图具体实现方法打开\themes\next\layout\_partials\footer.swig文件,在copyright前加上画红线这句话：代码如下：1&lt;script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"&gt;&lt;/script&gt;然后再合适的位置添加显示统计的代码，如图：代码如下：12345&lt;div class="powered-by"&gt;&lt;i class="fa fa-user-md"&gt;&lt;/i&gt;&lt;span id="busuanzi_container_site_uv"&gt; 本站访客数:&lt;span id="busuanzi_value_site_uv"&gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;在这里有两中不同计算方式的统计代码：pv的方式，单个用户连续点击n篇文章，记录n次访问量123&lt;span id="busuanzi_container_site_pv"&gt; 本站总访问量&lt;span id="busuanzi_value_site_pv"&gt;&lt;/span&gt;次&lt;/span&gt;uv的方式，单个用户连续点击n篇文章，只记录1次访客数123&lt;span id="busuanzi_container_site_uv"&gt; 本站总访问量&lt;span id="busuanzi_value_site_uv"&gt;&lt;/span&gt;次&lt;/span&gt;添加之后再执行hexo d -g，然后再刷新页面就能看到效果14. 添加热度实现效果图具体实现方法next主题集成leanCloud，打开/themes/next/layout/_macro/post.swig,在画红线的区域添加℃：然后打开，/themes/next/languages/zh-Hans.yml,将画红框的改为热度就可以了15. 网站底部字数统计实现效果图具体方法实现切换到根目录下，然后运行如下代码1$ npm install hexo-wordcount --save然后在/themes/next/layout/_partials/footer.swig文件尾部加上：1234&lt;div class="theme-info"&gt; &lt;div class="powered-by"&gt;&lt;/div&gt; &lt;span class="post-count"&gt;博客全站共&#123;&#123; totalcount(site) &#125;&#125;字&lt;/span&gt;&lt;/div&gt;16. 添加 README.md 文件每个项目下一般都有一个 README.md 文件，但是使用 hexo 部署到仓库后，项目下是没有 README.md 文件的。在 Hexo 目录下的 source 根目录下添加一个 README.md 文件，修改站点配置文件 _config.yml，将 skip_render 参数的值设置为1skip_render: README.md保存退出即可。再次使用 hexo d 命令部署博客的时候就不会在渲染 README.md 这个文件了。17. 设置网站的图标Favicon实现效果图具体方法实现在EasyIcon中找一张（32*32）的ico图标,或者去别的网站下载或者制作，并将图标名称改为favicon.ico，然后把图标放在/themes/next/source/images里，并且修改主题配置文件：12# Put your favicon.ico into `hexo-site/source/` directory.favicon: /favicon.ico18. 实现统计功能实现效果图具体实现方法在根目录下安装 hexo-wordcount,运行：1$ npm install hexo-wordcount --save然后在主题的配置文件中，配置如下：123456# Post wordcount display settings# Dependencies: https://github.com/willin/hexo-wordcountpost_wordcount: item_text: true wordcount: true min2read: true19. 添加顶部加载条实现效果图具体实现方法打开/themes/next/layout/_partials/head.swig文件，添加红框上的代码代码如下：12&lt;script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"&gt;&lt;/script&gt;&lt;link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet"&gt;但是，默认的是粉色的，要改变颜色可以在/themes/next/layout/_partials/head.swig文件中添加如下代码（接在刚才link的后面）12345678910111213&lt;style&gt; .pace .pace-progress &#123; background: #1E92FB; /*进度条颜色*/ height: 3px; &#125; .pace .pace-progress-inner &#123; box-shadow: 0 0 10px #1E92FB, 0 0 5px #1E92FB; /*阴影颜色*/ &#125; .pace .pace-activity &#123; border-top-color: #1E92FB; /*上边框颜色*/ border-left-color: #1E92FB; /*左边框颜色*/ &#125;&lt;/style&gt;目前，博主的增加顶部加载条的pull request 已被Merge😀===&gt;详情现在升级最新版的next主题，升级后只需修改主题配置文件(_config.yml)将pace: false改为pace: true就行了，你还可以换不同样式的加载条，如下图：20. 在文章底部增加版权信息实现效果图在目录 next/layout/_macro/下添加 my-copyright.swig：123456789101112131415161718192021222324252627282930&#123;% if page.copyright %&#125;&lt;div class="my_post_copyright"&gt; &lt;script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"&gt;&lt;/script&gt; &lt;!-- JS库 sweetalert 可修改路径 --&gt; &lt;script src="https://cdn.bootcss.com/jquery/2.0.0/jquery.min.js"&gt;&lt;/script&gt; &lt;script src="https://unpkg.com/sweetalert/dist/sweetalert.min.js"&gt;&lt;/script&gt; &lt;p&gt;&lt;span&gt;本文标题:&lt;/span&gt;&lt;a href="&#123;&#123; url_for(page.path) &#125;&#125;"&gt;&#123;&#123; page.title &#125;&#125;&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;span&gt;文章作者:&lt;/span&gt;&lt;a href="/" title="访问 &#123;&#123; theme.author &#125;&#125; 的个人博客"&gt;&#123;&#123; theme.author &#125;&#125;&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;span&gt;发布时间:&lt;/span&gt;&#123;&#123; page.date.format("YYYY年MM月DD日 - HH:mm") &#125;&#125;&lt;/p&gt; &lt;p&gt;&lt;span&gt;最后更新:&lt;/span&gt;&#123;&#123; page.updated.format("YYYY年MM月DD日 - HH:mm") &#125;&#125;&lt;/p&gt; &lt;p&gt;&lt;span&gt;原始链接:&lt;/span&gt;&lt;a href="&#123;&#123; url_for(page.path) &#125;&#125;" title="&#123;&#123; page.title &#125;&#125;"&gt;&#123;&#123; page.permalink &#125;&#125;&lt;/a&gt; &lt;span class="copy-path" title="点击复制文章链接"&gt;&lt;i class="fa fa-clipboard" data-clipboard-text="&#123;&#123; page.permalink &#125;&#125;" aria-label="复制成功！"&gt;&lt;/i&gt;&lt;/span&gt; &lt;/p&gt; &lt;p&gt;&lt;span&gt;许可协议:&lt;/span&gt;&lt;i class="fa fa-creative-commons"&gt;&lt;/i&gt; &lt;a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)"&gt;署名-非商业性使用-禁止演绎 4.0 国际&lt;/a&gt; 转载请保留原文链接及作者。&lt;/p&gt; &lt;/div&gt;&lt;script&gt; var clipboard = new Clipboard('.fa-clipboard'); $(".fa-clipboard").click(function()&#123; clipboard.on('success', function()&#123; swal(&#123; title: "", text: '复制成功', icon: "success", showConfirmButton: true &#125;); &#125;); &#125;); &lt;/script&gt;&#123;% endif %&#125;在目录next/source/css/_common/components/post/下添加my-post-copyright.styl：123456789101112131415161718192021222324252627282930313233343536373839404142434445.my_post_copyright &#123; width: 85%; max-width: 45em; margin: 2.8em auto 0; padding: 0.5em 1.0em; border: 1px solid #d3d3d3; font-size: 0.93rem; line-height: 1.6em; word-break: break-all; background: rgba(255,255,255,0.4);&#125;.my_post_copyright p&#123;margin:0;&#125;.my_post_copyright span &#123; display: inline-block; width: 5.2em; color: #b5b5b5; font-weight: bold;&#125;.my_post_copyright .raw &#123; margin-left: 1em; width: 5em;&#125;.my_post_copyright a &#123; color: #808080; border-bottom:0;&#125;.my_post_copyright a:hover &#123; color: #a3d2a3; text-decoration: underline;&#125;.my_post_copyright:hover .fa-clipboard &#123; color: #000;&#125;.my_post_copyright .post-url:hover &#123; font-weight: normal;&#125;.my_post_copyright .copy-path &#123; margin-left: 1em; width: 1em; +mobile()&#123;display:none;&#125;&#125;.my_post_copyright .copy-path:hover &#123; color: #808080; cursor: pointer;&#125;修改next/layout/_macro/post.swig，在代码12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include 'wechat-subscriber.swig' %&#125; &#123;% endif %&#125;&lt;/div&gt;之前添加增加如下代码：12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include 'my-copyright.swig' %&#125; &#123;% endif %&#125;&lt;/div&gt;如下：修改next/source/css/_common/components/post/post.styl文件，在最后一行增加代码：1@import "my-post-copyright"保存重新生成即可。如果要在该博文下面增加版权信息的显示，需要在 Markdown 中增加copyright: true的设置，类似：小技巧：如果你觉得每次都要输入copyright: true很麻烦的话,那么在/scaffolds/post.md文件中添加：这样每次hexo new &quot;你的内容&quot;之后，生成的md文件会自动把copyright:加到里面去(注意：如果解析出来之后，你的原始链接有问题：如：http://yoursite.com/前端小项目：使用canvas绘画哆啦A梦.html,那么在根目录下_config.yml中写成类似这样：）就行了。21. 添加网易云跟帖(跟帖关闭，已失效，改为来必力)实现效果图具体方法实现有两种实现方法：①更新next主题，因为最新版本的主题已经支持这种评论。直接在主题配置文件_config.yml 文件中添加如下配置:1gentie_productKey: #your-gentie-product-key②如果你不想更新的话，那么按下面步骤进行：首先，还是在主题配置文件_config.yml 文件中添加如下配置:1gentie_productKey: #your-gentie-product-key你的productKey就是下面画红线部分然后在在layout/_scripts/third-party/comments/ 目录中添加 gentie.swig，文件内容如下：1234567891011121314&#123;% if not (theme.duoshuo and theme.duoshuo.shortname) and not theme.duoshuo_shortname and not theme.disqus_shortname and not theme.hypercomments_id %&#125; &#123;% if theme.gentie_productKey %&#125; &#123;% set gentie_productKey = theme.gentie_productKey %&#125; &lt;script&gt; var cloudTieConfig = &#123; url: document.location.href, sourceId: "", productKey: "&#123;&#123;gentie_productKey&#125;&#125;", target: "cloud-tie-wrapper" &#125;; &lt;/script&gt; &lt;script src="https://img1.ws.126.net/f2e/tie/yun/sdk/loader.js"&gt;&lt;/script&gt; &#123;% endif %&#125;&#123;% endif %&#125;然后在layout/_scripts/third-party/comments.swig文件中追加：1&#123;% include './comments/gentie.swig' %&#125;最后，在 layout/_partials/comments.swig 文件中条件最后追加网易云跟帖插件引用的判断逻辑：123&#123;% elseif theme.gentie_productKey %&#125; &lt;div id="cloud-tie-wrapper" class="cloud-tie-wrapper"&gt; &lt;/div&gt;具体位置如下：可能你hexo s时可能看不到，直接hexo d就可以看到了近日，我朋友发来消息，说网易云跟帖要关了，我网上查了一下，果然如此😭都是泪,上次用了多说，结果多说关了，接着是网易云跟帖😷，这次直接用国外的来必力，应该不会这么容易关吧😏方法其实还是跟上面差不多的首先在 _config.yml 文件中添加如下配置：(注意！如果主题是最新版的，直接写你的liver_uid就行了)123# Support for LiveRe comments system.# You can get your uid from https://livere.com/insight/myCode (General web site)livere_uid: your uid其中，livere_uid就是画红线的部分然后在 layout/_scripts/third-party/comments/ 目录中添加 livere.swig，文件内容如下：1234567891011121314&#123;% if not (theme.duoshuo and theme.duoshuo.shortname) and not theme.duoshuo_shortname and not theme.disqus_shortname and not theme.hypercomments_id and not theme.gentie_productKey %&#125; &#123;% if theme.livere_uid %&#125; &lt;script type="text/javascript"&gt; (function(d, s) &#123; var j, e = d.getElementsByTagName(s)[0]; if (typeof LivereTower === 'function') &#123; return; &#125; j = d.createElement(s); j.src = 'https://cdn-city.livere.com/js/embed.dist.js'; j.async = true; e.parentNode.insertBefore(j, e); &#125;)(document, 'script'); &lt;/script&gt; &#123;% endif %&#125;&#123;% endif %&#125;然后在 layout/_scripts/third-party/comments.swig文件中追加：1&#123;% include './comments/livere.swig' %&#125;最后，在 layout/_partials/comments.swig 文件中条件最后追加 LiveRe 插件是否引用的判断逻辑：123&#123;% elseif theme.livere_uid %&#125; &lt;div id="lv-container" data-id="city" data-uid="&#123;&#123; theme.livere_uid &#125;&#125;"&gt;&lt;/div&gt;&#123;% endif %&#125;完22. 隐藏网页底部powered By Hexo / 强力驱动打开themes/next/layout/_partials/footer.swig,使用””隐藏之间的代码即可，或者直接删除。位置如图：23. 修改网页底部的桃心还是打开themes/next/layout/_partials/footer.swig，找到：，然后还是在图标库中找到你自己喜欢的图标，然后修改画红线的部分就可以了。24. 文章加密访问实现效果图具体实现方法打开themes-&gt;next-&gt;layout-&gt;_partials-&gt;head.swig文件,在以下位置插入这样一段代码：代码如下：1234567891011121314&lt;script&gt; (function () &#123; if ('&#123;&#123; page.password &#125;&#125;') &#123; if (prompt('请输入文章密码') !== '&#123;&#123; page.password &#125;&#125;') &#123; alert('密码错误！'); if (history.length === 1) &#123; location.replace("http://xxxxxxx.xxx"); // 这里替换成你的首页 &#125; else &#123; history.back(); &#125; &#125; &#125; &#125;)();&lt;/script&gt;然后在文章上写成类似这样：25. 添加jiathis分享注意：JiaThis 不支持 https在主题配置文件中，JiaThis为true，就行了，如下图默认是这样子的：如果你想自定义话，打开themes/next/layout/_partials/share/jiathis.swig修改画红线部分就可以了26. 博文置顶修改 hero-generator-index 插件，把文件：node_modules/hexo-generator-index/lib/generator.js 内的代码替换为：12345678910111213141516171819202122232425262728'use strict';var pagination = require('hexo-pagination');module.exports = function(locals)&#123; var config = this.config; var posts = locals.posts; posts.data = posts.data.sort(function(a, b) &#123; if(a.top &amp;&amp; b.top) &#123; // 两篇文章top都有定义 if(a.top == b.top) return b.date - a.date; // 若top值一样则按照文章日期降序排 else return b.top - a.top; // 否则按照top值降序排 &#125; else if(a.top &amp;&amp; !b.top) &#123; // 以下是只有一篇文章top有定义，那么将有top的排在前面（这里用异或操作居然不行233） return -1; &#125; else if(!a.top &amp;&amp; b.top) &#123; return 1; &#125; else return b.date - a.date; // 都没定义按照文章日期降序排 &#125;); var paginationDir = config.pagination_dir || 'page'; return pagination('', posts, &#123; perPage: config.index_generator.per_page, layout: ['index', 'archive'], format: paginationDir + '/%d/', data: &#123; __index: true &#125; &#125;);&#125;;在文章中添加 top 值，数值越大文章越靠前，如12345678---title: 解决Charles乱码问题date: 2017-05-22 22:45:48tags: 技巧categories: 技巧copyright: truetop: 100---27. 修改字体大小打开\themes\next\source\css\ _variables\base.styl文件，将$font-size-base改成16px，如下所示：1$font-size-base =16px28. 修改打赏字体不闪动修改文件next/source/css/_common/components/post/post-reward.styl，然后注释其中的函数wechat:hover和alipay:hover，如下：123456789101112/* 注释文字闪动函数 #wechat:hover p&#123; animation: roll 0.1s infinite linear; -webkit-animation: roll 0.1s infinite linear; -moz-animation: roll 0.1s infinite linear;&#125; #alipay:hover p&#123; animation: roll 0.1s infinite linear; -webkit-animation: roll 0.1s infinite linear; -moz-animation: roll 0.1s infinite linear;&#125;*/29. 侧边栏推荐阅读今天有位网友问推荐阅读是怎么弄，其实挺简单的，打开主题配置文件修改成这样就行了(links里面写你想要的链接):1234567891011# Blogrollslinks_title: 推荐阅读#links_layout: blocklinks_layout: inlinelinks: 优设: http://www.uisdc.com/ 张鑫旭: http://www.zhangxinxu.com/ Web前端导航: http://www.alloyteam.com/nav/ 前端书籍资料: http://www.36zhen.com/t?id=3448 百度前端技术学院: http://ife.baidu.com/ google前端开发基础: http://wf.uisdc.com/cn/30. 自定义鼠标样式打开themes/next/source/css/_custom/custom.styl,在里面写下如下代码1234567// 鼠标样式 * &#123; cursor: url("http://om8u46rmb.bkt.clouddn.com/sword2.ico"),auto!important &#125; :active &#123; cursor: url("http://om8u46rmb.bkt.clouddn.com/sword1.ico"),auto!important &#125;其中 url 里面必须是 ico 图片，ico 图片可以上传到网上（我是使用七牛云图床），然后获取外链，复制到 url 里就行了31.为博客加上萌萌的宠物实现效果图具体实现方法在终端切换到你的博客的路径里，然后输入如下代码：1npm install -save hexo-helper-live2d然后打开Hexo/blog/themes/next/layout的_layout.swig,将下面代码放到&lt;/body&gt;之前：(注意，由于官方更新了包，所以画删除线的不用弄)然后在在 hexo 的 _config.yml中添加参数：（具体配置可以看官方文档）1234567891011121314live2d: enable: true scriptFrom: local pluginRootPath: live2dw/ pluginJsPath: lib/ pluginModelPath: assets/ model: use: live2d-widget-model-wanko display: position: right width: 150 height: 300 mobile: show: true然后hexo clean ，hexo g ，hexo d 就可以看到了。注意！如果你在 hexo d 的时候出现我下面这个问题你可以这样，首先删除hexo 下面的.deploy_git文件夹，然后运行1git config --global core.autocrlf false重新 hexo clean,hexo g,hexo d就行了32.DaoVoice 在线联系实现效果图具体实现方法首先在 daovoice 注册账号,邀请码是0f81ff2f，注册完成后会得到一个 app_id :记下这个 app_id的值，然后打开/themes/next/layout/_partials/head.swig,写下如下代码：123456789&#123;% if theme.daovoice %&#125; &lt;script&gt; (function(i,s,o,g,r,a,m)&#123;i["DaoVoiceObject"]=r;i[r]=i[r]||function()&#123;(i[r].q=i[r].q||[]).push(arguments)&#125;,i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset="utf-8";m.parentNode.insertBefore(a,m)&#125;)(window,document,"script",('https:' == document.location.protocol ? 'https:' : 'http:') + "//widget.daovoice.io/widget/0f81ff2f.js","daovoice") daovoice('init', &#123; app_id: "&#123;&#123;theme.daovoice_app_id&#125;&#125;" &#125;); daovoice('update'); &lt;/script&gt;&#123;% endif %&#125;接着打开主题配置文件，在最后写下如下代码：1234# Online contact daovoice: truedaovoice_app_id: 这里填你的刚才获得的 app_id重新 hexo g ，hexo s 就能看到效果了。安装成功后可以在DaoVoice 控制台上的聊天设置里设置聊天窗口样式，附上我的设置33.点击爆炸效果实现效果图实现方法跟那个红心是差不多的，首先在themes/next/source/js/src里面建一个叫fireworks.js的文件，代码如下：1"use strict";function updateCoords(e)&#123;pointerX=(e.clientX||e.touches[0].clientX)-canvasEl.getBoundingClientRect().left,pointerY=e.clientY||e.touches[0].clientY-canvasEl.getBoundingClientRect().top&#125;function setParticuleDirection(e)&#123;var t=anime.random(0,360)*Math.PI/180,a=anime.random(50,180),n=[-1,1][anime.random(0,1)]*a;return&#123;x:e.x+n*Math.cos(t),y:e.y+n*Math.sin(t)&#125;&#125;function createParticule(e,t)&#123;var a=&#123;&#125;;return a.x=e,a.y=t,a.color=colors[anime.random(0,colors.length-1)],a.radius=anime.random(16,32),a.endPos=setParticuleDirection(a),a.draw=function()&#123;ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.fillStyle=a.color,ctx.fill()&#125;,a&#125;function createCircle(e,t)&#123;var a=&#123;&#125;;return a.x=e,a.y=t,a.color="#F00",a.radius=0.1,a.alpha=0.5,a.lineWidth=6,a.draw=function()&#123;ctx.globalAlpha=a.alpha,ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.lineWidth=a.lineWidth,ctx.strokeStyle=a.color,ctx.stroke(),ctx.globalAlpha=1&#125;,a&#125;function renderParticule(e)&#123;for(var t=0;t&lt;e.animatables.length;t++)&#123;e.animatables[t].target.draw()&#125;&#125;function animateParticules(e,t)&#123;for(var a=createCircle(e,t),n=[],i=0;i&lt;numberOfParticules;i++)&#123;n.push(createParticule(e,t))&#125;anime.timeline().add(&#123;targets:n,x:function(e)&#123;return e.endPos.x&#125;,y:function(e)&#123;return e.endPos.y&#125;,radius:0.1,duration:anime.random(1200,1800),easing:"easeOutExpo",update:renderParticule&#125;).add(&#123;targets:a,radius:anime.random(80,160),lineWidth:0,alpha:&#123;value:0,easing:"linear",duration:anime.random(600,800)&#125;,duration:anime.random(1200,1800),easing:"easeOutExpo",update:renderParticule,offset:0&#125;)&#125;function debounce(e,t)&#123;var a;return function()&#123;var n=this,i=arguments;clearTimeout(a),a=setTimeout(function()&#123;e.apply(n,i)&#125;,t)&#125;&#125;var canvasEl=document.querySelector(".fireworks");if(canvasEl)&#123;var ctx=canvasEl.getContext("2d"),numberOfParticules=30,pointerX=0,pointerY=0,tap="mousedown",colors=["#FF1461","#18FF92","#5A87FF","#FBF38C"],setCanvasSize=debounce(function()&#123;canvasEl.width=2*window.innerWidth,canvasEl.height=2*window.innerHeight,canvasEl.style.width=window.innerWidth+"px",canvasEl.style.height=window.innerHeight+"px",canvasEl.getContext("2d").scale(2,2)&#125;,500),render=anime(&#123;duration:1/0,update:function()&#123;ctx.clearRect(0,0,canvasEl.width,canvasEl.height)&#125;&#125;);document.addEventListener(tap,function(e)&#123;"sidebar"!==e.target.id&amp;&amp;"toggle-sidebar"!==e.target.id&amp;&amp;"A"!==e.target.nodeName&amp;&amp;"IMG"!==e.target.nodeName&amp;&amp;(render.play(),updateCoords(e),animateParticules(pointerX,pointerY))&#125;,!1),setCanvasSize(),window.addEventListener("resize",setCanvasSize,!1)&#125;"use strict";function updateCoords(e)&#123;pointerX=(e.clientX||e.touches[0].clientX)-canvasEl.getBoundingClientRect().left,pointerY=e.clientY||e.touches[0].clientY-canvasEl.getBoundingClientRect().top&#125;function setParticuleDirection(e)&#123;var t=anime.random(0,360)*Math.PI/180,a=anime.random(50,180),n=[-1,1][anime.random(0,1)]*a;return&#123;x:e.x+n*Math.cos(t),y:e.y+n*Math.sin(t)&#125;&#125;function createParticule(e,t)&#123;var a=&#123;&#125;;return a.x=e,a.y=t,a.color=colors[anime.random(0,colors.length-1)],a.radius=anime.random(16,32),a.endPos=setParticuleDirection(a),a.draw=function()&#123;ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.fillStyle=a.color,ctx.fill()&#125;,a&#125;function createCircle(e,t)&#123;var a=&#123;&#125;;return a.x=e,a.y=t,a.color="#F00",a.radius=0.1,a.alpha=0.5,a.lineWidth=6,a.draw=function()&#123;ctx.globalAlpha=a.alpha,ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.lineWidth=a.lineWidth,ctx.strokeStyle=a.color,ctx.stroke(),ctx.globalAlpha=1&#125;,a&#125;function renderParticule(e)&#123;for(var t=0;t&lt;e.animatables.length;t++)&#123;e.animatables[t].target.draw()&#125;&#125;function animateParticules(e,t)&#123;for(var a=createCircle(e,t),n=[],i=0;i&lt;numberOfParticules;i++)&#123;n.push(createParticule(e,t))&#125;anime.timeline().add(&#123;targets:n,x:function(e)&#123;return e.endPos.x&#125;,y:function(e)&#123;return e.endPos.y&#125;,radius:0.1,duration:anime.random(1200,1800),easing:"easeOutExpo",update:renderParticule&#125;).add(&#123;targets:a,radius:anime.random(80,160),lineWidth:0,alpha:&#123;value:0,easing:"linear",duration:anime.random(600,800)&#125;,duration:anime.random(1200,1800),easing:"easeOutExpo",update:renderParticule,offset:0&#125;)&#125;function debounce(e,t)&#123;var a;return function()&#123;var n=this,i=arguments;clearTimeout(a),a=setTimeout(function()&#123;e.apply(n,i)&#125;,t)&#125;&#125;var canvasEl=document.querySelector(".fireworks");if(canvasEl)&#123;var ctx=canvasEl.getContext("2d"),numberOfParticules=30,pointerX=0,pointerY=0,tap="mousedown",colors=["#FF1461","#18FF92","#5A87FF","#FBF38C"],setCanvasSize=debounce(function()&#123;canvasEl.width=2*window.innerWidth,canvasEl.height=2*window.innerHeight,canvasEl.style.width=window.innerWidth+"px",canvasEl.style.height=window.innerHeight+"px",canvasEl.getContext("2d").scale(2,2)&#125;,500),render=anime(&#123;duration:1/0,update:function()&#123;ctx.clearRect(0,0,canvasEl.width,canvasEl.height)&#125;&#125;);document.addEventListener(tap,function(e)&#123;"sidebar"!==e.target.id&amp;&amp;"toggle-sidebar"!==e.target.id&amp;&amp;"A"!==e.target.nodeName&amp;&amp;"IMG"!==e.target.nodeName&amp;&amp;(render.play(),updateCoords(e),animateParticules(pointerX,pointerY))&#125;,!1),setCanvasSize(),window.addEventListener("resize",setCanvasSize,!1)&#125;;打开themes/next/layout/_layout.swig,在&lt;/body&gt;上面写下如下代码：12345&#123;% if theme.fireworks %&#125; &lt;canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" &gt;&lt;/canvas&gt; &lt;script type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="/js/src/fireworks.js"&gt;&lt;/script&gt;&#123;% endif %&#125;打开主题配置文件，在里面最后写下：12# Fireworksfireworks: true完😀致谢感谢大神们的文章，真的学到了许多，有些忘了记录下来，在这里由衷的感谢。虽然比较折腾，但是确实满满的成就感，Road endless its long and far, I will seek up and down！欢迎访问我的博客参考的文章：http://blog.csdn.net/MasterAnt_D/article/details/56839222http://zidingyi4qh.com/2017/04/27/NexT%E5%BA%95%E9%83%A8logo%E6%B7%BB%E5%8A%A0%E8%AE%BF%E9%97%AE%E9%87%8F/https://fuyis.me/2017/01/25/Hexo-theme-next-and-optimized-configuration/http://www.vitah.net/posts/20f300cc/http://thief.one/2017/03/03/Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/https://chanshiyu.com/2017/11/24/%E5%8F%98%E5%BD%A2%E8%AE%B0%20%E2%97%8F%20NexT%E4%B8%BB%E9%A2%98%E7%BE%8E%E5%8C%96/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[前端小项目：使用canvas绘画哆啦A梦]]></title>
      <url>%2F%E5%89%8D%E7%AB%AF%E5%B0%8F%E9%A1%B9%E7%9B%AE%EF%BC%9A%E4%BD%BF%E7%94%A8canvas%E7%BB%98%E7%94%BB%E5%93%86%E5%95%A6A%E6%A2%A6.html</url>
      <content type="text"><![CDATA[最近在学canvas元素,&lt;canvas&gt;标签只是图形容器，必须使用js来绘制图形。为了增强对canvas元素的理解,于是用canvas画了一个哆啦A梦来要实现的效果图在线预览要想绘画出这个哆啦a梦首先要掌握以下一些函数：arcTo()canvas绘制圆形或弧线bezierCurveTo()quadraticCurveTo()开始绘画！！首先我们需要创建一个400*600的画布，代码如下:1&lt;canvas id="doraemon" width="400" height="600"&gt;&lt;/canvas&gt;接着定义一个div，用来显示坐标1&lt;div id="put" style="width: 50px" height="20px"&gt;&lt;/div&gt;接着我写了一个显示坐标的函数，可以用来看大概画到哪个点：123456function zuobiao(event) &#123; var x = event.clientX; var y = event.clientY; var out = document.getElementById("put"); out.innerHTML = "x:" + x + " y:" + y; &#125;然后getContext() 方法返回一个用于在画布上绘图的环境。1var cxt = document.getElementById('doraemon').getContext('2d');接着开始画头部:1234567cxt.beginPath();//起始路径cxt.lineWidth = 1;//线宽度为1cxt.strokeStyle = '#000';//笔触的颜色cxt.arc(200, 175, 175, 0.7 * Math.PI, 0.3 * Math.PI);//绘制弧，中心点（200，175），半径175cxt.fillStyle = '#0bb0da';//设置填充时的颜色cxt.fill();//填充颜色cxt.stroke();//绘制路径头部如下：接着绘画出脸部：123456789cxt.beginPath();cxt.fillStyle = '#fff';cxt.moveTo(110, 110);//将路径移到点（110，110），不创建线条cxt.quadraticCurveTo(-10, 200, 120, 315);//创建二次贝塞尔曲线,控制点(-10,200),结束点(120,315)cxt.lineTo(280, 315);//添加一个新点，然后在画布中创建从（110，110）到（280，315）的线条cxt.quadraticCurveTo(410, 210, 290, 110);cxt.lineTo(110, 110);cxt.fill();cxt.stroke();脸部如下：接着绘画眼睛：1234567891011cxt.beginPath();cxt.lineWidth = 1;cxt.fillStyle = '#fff';cxt.moveTo(110, 110);cxt.bezierCurveTo(110, 25, 200, 25, 200, 100);//创建三次贝塞尔曲线,控制点1(110,25),控制点2(200,25),结束点(200,100)，也就是画左上半椭圆cxt.bezierCurveTo(200, 175, 110, 175, 110, 100);//画左下半椭圆cxt.moveTo(200, 100);cxt.bezierCurveTo(200, 25, 290, 25, 290, 100);cxt.bezierCurveTo(290, 175, 200, 175, 200, 100);cxt.fill();cxt.stroke();接着画左右眼球：123456789101112 /*右眼球*/cxt.beginPath();cxt.fillStyle = '#000';cxt.arc(230, 130, 12, 0, 2 * Math.PI);cxt.fill();cxt.stroke();/*左眼球*/cxt.beginPath();cxt.fillStyle = '#000';cxt.arc(170, 130, 12, 0, 2 * Math.PI);cxt.fill();cxt.stroke();左右眼球：接着画鼻子：12345cxt.beginPath();cxt.arc(200, 165, 25, 0, 2 * Math.PI);cxt.fillStyle = '#d05823';cxt.fill();cxt.stroke();鼻子：接着画胡须：12345678910111213141516171819//左胡须cxt.beginPath();cxt.moveTo(80, 175);cxt.lineTo(150, 195);cxt.moveTo(80, 200);cxt.lineTo(150, 205);cxt.moveTo(80, 225);cxt.lineTo(150, 215);//中部胡须cxt.moveTo(200, 195);cxt.lineTo(200, 290);//右胡须cxt.moveTo(250, 195);cxt.lineTo(320, 175);cxt.moveTo(250, 205);cxt.lineTo(320, 200);cxt.moveTo(250, 215);cxt.lineTo(320, 225);cxt.stroke();胡须:接着画嘴：123cxt.moveTo(80, 240);cxt.quadraticCurveTo(200, 350, 320, 240);cxt.stroke();嘴：接下来画围巾：123456789101112131415cxt.beginPath();cxt.moveTo(96, 316);cxt.lineTo(305, 316);cxt.lineTo(320, 316);cxt.arcTo(330, 316, 330, 326, 10);//在画布上创建介于两个切线之间的弧，起点坐标为(330,316),终点坐标为(330,326),半径为10cxt.lineTo(330, 336);cxt.arcTo(330, 346, 305, 346, 10);cxt.lineTo(81, 346);cxt.arcTo(71, 346, 71, 336, 10);cxt.lineTo(71, 326);cxt.arcTo(71, 316, 81, 316, 10);cxt.lineTo(96, 316);cxt.fillStyle = '#b13209';cxt.fill();cxt.stroke();围巾：接着画衣服：1234567891011121314151617cxt.beginPath();cxt.fillStyle = '#0bb0da';cxt.moveTo(80, 346);//左衣服cxt.lineTo(26, 406);cxt.lineTo(65, 440);cxt.lineTo(85, 418);cxt.lineTo(85, 528);cxt.lineTo(185, 528);//右衣服cxt.lineTo(315, 528);cxt.lineTo(315, 418);cxt.lineTo(337, 440);cxt.lineTo(374, 406);cxt.lineTo(320, 346);cxt.fill();cxt.stroke();衣服：接着画手：123456789101112//左手cxt.beginPath();cxt.fillStyle = '#fff';cxt.arc(37, 433, 30, 0, 2 * Math.PI);cxt.fill();cxt.stroke();//右手cxt.beginPath();cxt.fillStyle = '#fff';cxt.arc(363, 433, 30, 0, 2 * Math.PI);cxt.fill();cxt.stroke();手：接着画肚：12345cxt.beginPath();cxt.fillStyle = '#fff';cxt.arc(200, 400, 91, 1.8 * Math.PI, 1.2 * Math.PI);cxt.fill();cxt.stroke();肚：接着画小口袋12345678cxt.beginPath();cxt.fillStyle = '#fff';cxt.moveTo(130, 394);cxt.lineTo(270, 394);cxt.moveTo(130, 394);cxt.bezierCurveTo(130, 490, 270, 490, 270, 394);cxt.fill();cxt.stroke();小口袋：最后画两只脚以及两只脚的的空隙：1234567891011121314151617181920212223242526272829/*两只脚的空隙*/ cxt.beginPath(); cxt.fillStyle = '#fff'; cxt.arc(200, 529, 20,Math.PI, 0); cxt.fill(); cxt.stroke(); /*脚*/ //左脚 cxt.beginPath(); cxt.fillStyle='#fff'; cxt.moveTo(180,528); cxt.lineTo(72,528); cxt.bezierCurveTo(52,528,52,558,72,558); cxt.lineTo(180,558); cxt.moveTo(180,558); cxt.bezierCurveTo(200,558,200,528,180,528); cxt.fill(); cxt.stroke(); //右脚 cxt.beginPath(); cxt.fillStyle='#fff'; cxt.moveTo(220,528); cxt.lineTo(328,528); cxt.bezierCurveTo(348,528,348,558,328,558); cxt.lineTo(220,558); cxt.moveTo(220,558); cxt.bezierCurveTo(200,558,200,528,220,528); cxt.fill(); cxt.stroke();完成了︿(￣︶￣)︿完整代码请点击：哆啦A梦]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[有关HTML常被问到的知识点]]></title>
      <url>%2F%E6%9C%89%E5%85%B3HTML%E5%B8%B8%E8%A2%AB%E9%97%AE%E5%88%B0%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9.html</url>
      <content type="text"><![CDATA[HTML、XML、XHTML 有什么区别?HTML即是超文本标记语言（Hyper Text Markup Language），是最早写网页的语言，但是由于时间早，规范不是很好，大小写混写且编码不规范,是语法较为松散的、不严格的Web语言XHTML是升级版的html（Extensible Hyper Text Markup Language），对html进行了规范，编码更加严谨纯洁，也是一种过渡语言，html向xml过渡的语言。实际上XHTML 与 HTML 4.01 标准没有太多的不同。XML是可扩展标记语言（Extensible Markup Language），是一种跨平台语言，编码更自由，可以自由创建标签（比如像下面这样创建：123456&lt;note&gt;&lt;to&gt;Tove&lt;/to&gt;&lt;from&gt;Jani&lt;/from&gt;&lt;heading&gt;Reminder&lt;/heading&gt;&lt;body&gt;Don't forget me this weekend!&lt;/body&gt;&lt;/note&gt;），主要用于存储数据和结构，可扩展HTML和XML的区别：XML 被设计用来传输和存储数据，其焦点是数据的内容。HTML 被设计用来显示数据，其焦点是数据的外观。HTML 旨在显示信息，而 XML 旨在传输信息。XML在定义标记时区分大小写，而HTML标记不区分大小写。HTML和XHTML的区别：XHTML 元素必须被正确地嵌套。例如：XHTML必须要这样&lt;b&gt;&lt;i&gt;This text is bold and italic&lt;/i&gt;&lt;/b&gt;而在 HTML 中，某些元素可以像这样彼此不正确地嵌套：&lt;b&gt;&lt;i&gt;This text is bold and italic&lt;/b&gt;&lt;/i&gt;XHTML 元素必须被关闭。例如&lt;p&gt;This is a paragraph&lt;/p&gt;===&gt;&gt;这是正确的&lt;p&gt;This is a paragraph===&gt;&gt;这是错误的标签名必须用小写字母。例如: &lt;p&gt;This is a paragraph&lt;/p&gt;==&gt;&gt;这是正确的&lt;P&gt;This is a paragraph&lt;/P&gt;===&gt;&gt;这是错误的XHTML 文档必须拥有根元素。所有的 XHTML 元素必须被嵌套于 &lt;html&gt; 根元素中怎样理解 HTML 语义化?HTML语义化是让大家直观的认识标签(markup)和属性(attribute)的用途和作用，选择合适的标签（代码语义化）便于开发者阅读和写出更优雅的代码的同时让浏览器的爬虫和机器很好地解析，并且便于团队开发和维护。怎样理解内容与样式分离的原则?写 HTML 的时候先不管样式, 重点放在HTML的结构和语义化上，让 HTML 能体现页面结构或者内容。之后再去写样式。写 JS 的时候，尽量不要用 JS 去直接操作样式，而是通过给元素添加删除class来控制样式变化。文档结构与文档样式的分离可以确保网页的平稳退化，也让内容和样式在可以分开独立编辑。有哪些常见的meta标签?指定字符集&lt;meta charset=&quot;utf-8&quot;&gt;向搜索引擎说明你的网页的关键词&lt;meta name=&quot;keywords&quot; content=&quot;&quot;&gt;告诉搜索引擎你的站点的主要内容&lt;meta name=&quot;description&quot; content=&quot;&quot;&gt;告诉搜索引擎你的站点的制作的作者&lt;meta name=&quot;author&quot; content=&quot;your name&quot;&gt;响应式页面&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;定时让网页在3秒内跳转到mozilla首页(http-equiv 属性为名称/值对提供了名称。并指示服务器在发送实际的文档之前先在要传送给浏览器的 MIME 文档头部包含名称/值对。)&lt;meta http-equiv=&quot;refresh&quot; content=&quot;3&quot; url=https://www.mozilla.org&quot;&gt;如果安装了GCF (Google Chrome Frame)，则使用GCF来渲染页面 (“chrome=1”), 如果没有安装GCF，则使用最高版本的IE内核进行渲染 (“IE=edge”)。X-UA-Compatible(浏览器采取何种版本渲染当前页面)&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot;&gt;浏览器的内核控制&lt;meta name=&quot;renderer&quot; content=&quot;webkit|ie-comp|ie-stand&quot;&gt;文档声明的作用?文档声明用来告知浏览器当前文档所使用的类型，让浏览器解析器知道要用什么规范来解析文档。严格模式和混杂模式指什么?在严格模式中，浏览器以其支持的最高标准呈现页面。在混杂模式中，又称怪异模式或兼容模式，浏览器用自己的方式解析代码，页面以一种比较宽松的向后兼容的方式显示。混杂模式通常模拟老式浏览器的行为以防止老站点无法工作。&lt;!doctype html&gt; 的作用?它是html5标准网页声明,告诉浏览器用最新的 HTML5标准来解析渲染页面；如果不写，浏览器就会进入混杂模式。浏览器乱码的原因是什么？如何解决？乱码产生的根本原因是保存的编码格式和浏览器解析时的解码格式不匹配导致的。解决方式： 写代码的时候在html 的 &lt;head&gt;里添加&lt;meta charset=&#39;xxx&#39;&gt;并且保存的时候仍选择同样的编码方式。常见的浏览器有哪些？什么内核？Internet explorer 使用的是TridentFirefox使用的是Gecko。opera之前使用的是Presto，后来用Blink苹果的Safari，谷歌的Chrome使用的是WebKit，还有国产的大部分双核浏览器其中一核就是WebKit。列出常见的标签，并简单介绍这些标签用在什么场景？标签运用场景&lt;html&gt;HTML 页面的根元素&lt;body&gt;文档的内容&lt;head&gt;用于定义文档的头部&lt;meta&gt;提供了元数据.元数据也不显示在页面上，被浏览器解析&lt;title&gt;文档的标题&lt;h1&gt;-&lt;h6&gt;定义了一级标题到六级标题，标题字体大小逐渐减弱&lt;p&gt;定义一个段落&lt;a&gt;网页链接&lt;div&gt;块级元素，它可用于组合其他 HTML 元素的容器,没有特定的含义&lt;span&gt;内联元素，也没有特定的含义，可用作文本的容器&lt;u&gt;下划线&lt;em&gt;强调文本&lt;strong&gt;加重文本&lt;ol&gt;有序列表&lt;ul&gt;无序列表&lt;li&gt;定义列表项目&lt;img&gt;图片&lt;br &gt;换行&lt;input&gt;定义输入控件&lt;i&gt;斜体字&lt;table&gt;定义表&lt;tr&gt;定义表格中的行&lt;td&gt;定义表中的单元格&lt;th&gt;定义表格的表头&lt;tbody&gt;定义表格的主体&lt;tfoot&gt;定义表格的页脚&lt;hr&gt;创建一条水平线&lt;iframe&gt;定义内联框架&lt;cite&gt;定义作品的标题&lt;button&gt;按钮&lt;b&gt;定义粗体文本&lt;form&gt;定义用于用户输入的HTML表单&lt;caption&gt;定义表标题&lt;footer&gt;定义文档或节的页脚]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[解决Charles乱码问题]]></title>
      <url>%2F%E8%A7%A3%E5%86%B3Charles%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98.html</url>
      <content type="text"><![CDATA[在网上查了半天说在Info.plist文件加字符串就好了，其实没有用，下面有一个方法亲试可以解决乱码问题安装ssl证书3.10版本之前的需要去http://www.charlesproxy.com/ssl.zip 下载 CA 证书文件，然后双击 .crt 文件，选择‘总是信任’按钮，在钥匙串访问中即可看到添加成功的证书。我是4.02版本的，在3.10版本之后的，操作如下：先点proxy中的macOS Proxy ，如果点击网页，Charles没有出现东西的话，把翻墙软件关了然后点击help中的SSL Proxying如下图：点击之后在搜索框中输入Charles，出现（我是已经改好了，原来的话是红色的）：双击那个证书，改成如下图所示，然后保存：接下来点击proxy中的SSL Proxying Settings，出现如下图所示，然后点add 在Host里填 * 号 ，在Port里填443，然后点ok：接下来，你会惊奇的发现，乱码没有了\（￣︶￣）/注意！！如果你开了 vpn，先要把 vpn 关掉，还有可能手机调试的时候Charles的左边会出现unknown，这个时候你需要在手机安装证书，步骤如下：点击 help -&gt; SSL Proxying -&gt; install Charles Root Certificate on a Mobile…点击完会出现手机和电脑处于同一个局域网，查看电脑的 ip 地址和查看 Charles 的端口在手机 wifi 上填写 http 代理在ios手机上的 safari 浏览器上输入 chls.pro/ssl ,然后跟着安装证书安装证书之后，在手机上的设置-&gt; 通用-&gt; 关于本机 -&gt; 证书信任设置-&gt; 点击信任你刚才安装的证书重启 Charles，完😀]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[github博客绑定个性域名]]></title>
      <url>%2Fgithub%E5%8D%9A%E5%AE%A2%E7%BB%91%E5%AE%9A%E4%B8%AA%E6%80%A7%E5%9F%9F%E5%90%8D.html</url>
      <content type="text"><![CDATA[首先我们先买个域名,可以在阿里云购买域名，买完之后登陆阿里云的管理控制台,然后点击域名，再点击解析如下接下来点击添加解析，并输入以下信息（记录值不一样，第一个的记录值填你的github访问地址,如shenzekun.github.io,第二个填的是你的网站的ip地址，比如我原来的网站是shenzekun.github.io,那么就查找shenzekun.github.io的ip地址，网站的ip地址可以在这查ip地址）然后向你的 Github Pages 仓库添加一个CNAME(一定要大写)文件，在CNAME里面添加你的域名信息（不加http://），如shenzekun.cn,并上传到你的GitHub中填完之后登陆你博客的github，点击setting在这填写你的域名，点击保存即可接下来就是等了，我的博客大概半个小时就可以看到了。😝]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[学生免费申请JetBrains许可证技巧]]></title>
      <url>%2F%E5%AD%A6%E7%94%9F%E5%85%8D%E8%B4%B9%E7%94%B3%E8%AF%B7JetBrains%E8%AE%B8%E5%8F%AF%E8%AF%81%E6%8A%80%E5%B7%A7.html</url>
      <content type="text"><![CDATA[用过JetBrain公司出的软件的人都知道，这个公司出的软件都比较好用，像webstorm，phpstrom等等，但是就是太贵了。对于学生，可以免费使用jetbrain公司的软件，那么接下来我会讲一讲如何申请免费学生免费申请许可证地址：https://www.jetbrains.com/student/点击apply now出现如下图：支持的验证方法有：邮件认证: 如果你的学校对学生有提供类似@.edu或者是 @.edu.cn 的邮箱，那么你可以通过这种方式去认证。ISIC/ITIC 认证： 这个没试过，不知道要怎么弄 —__—文档认证： 我是申请这个的，这个需要你的学生证 ===&gt;这里填你的学校就行了！Comment里面填一些你想说的话，然后点APPLY FOR FREE PRODUCTS，就申请完成了!等我是星期六申请的，星期一晚上就发邮件给我了，大约用了3天左右，如图：点 Activate Educational License就激活成功了！我用phpstrom举例子在这里输入你获得的许可证就能成功激活了。注意，许可证有效期为1年!（过期了可重新申请）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[前端面试题：从url到页面展现，这之中发生了什么？]]></title>
      <url>%2F%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E4%BB%8Eurl%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%8E%B0%EF%BC%8C%E8%BF%99%E4%B9%8B%E4%B8%AD%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88.html</url>
      <content type="text"><![CDATA[我们平常在地址栏里输入一些网址时，页面很快就会出现，但在这之中到底发生了什么事情呢？大概是这样的流程：在浏览器的地址栏中敲入了url域名解析服务器处理请求浏览器处理绘制网页一、在浏览器的地址栏中敲入了url首先，我们要知道url是什么？URL（Uniform Resource Locator），统一资源定位符，用于定位互联网上的资源，实际上就是网站网址。url的格式一般为：协议类型://&lt;主机名&gt;:&lt;端口&gt;/&lt;路径&gt;/文件名其中协议类型可以是http（超文本传输协议）、https、ftp（文件传输协议）、telnet（远程登录协议）、file等等。而http是最常见的网络传输协议，https则是进行加密的网络传输。例如，我的简书url为http://www.jianshu.com/u/b473784d730c，其中，“http”表示与web服务器通讯采用http协议，简书web服务器域名为www.jianshu.com，u/b473784d730c表示所访问的文件存在于web服务器上的路径。url格式中主机名冒号后面的数字是端口编号，因为一台计算机常常会同时作为Web，FTP等服务器，端口编号用来告诉web服务器所在的主机要将请求交给哪个服务。默认情况下http服务的端口为80，不需要在url中输入，如果web服务器采用的不是这一个默认端口，就需要写明服务所用的端口。常见的协议默认端口如下：协议类型默认端口http80ftp21https443telnet23IP是什么IP是因特网中的每台连接到网络的计算机为实现相互通信而遵循的规则协议。每个处于互联网中的设备都有IP 地址，形如 192.168.0.1，而127.0.0.1代表本机的 IP。IP又分为局域网IP和公网IP。而局域网 IP 和公网 IP 是有差别的。每个网站就是靠IP来定位的。为了便于记忆或辨识，人们使用域名来登录网站，每个域名背后有对应的IP地址。比如对于 http://www.jianshu.com的URL，浏览器实际上不知道 www.jianshu.com到底是什么东西，需要查找www.jianshu.com网站所在服务器的IP地址，才能找到目标，这就是下文要说的域名解析。二、域名解析当用户在浏览器中输入url后,你使用的电脑会发出一个DNS请求到本地DNS服务器。本地DNS服务器一般都是你的网络接入服务器商提供，比如中国电信，中国移动,DNS请求到达本地DNS服务器之后会有以下几个步骤：查找浏览器缓存浏览器会检查缓存中有没有这个域名对应的解析过的IP地址，如果缓存中有，这个解析过程就将结束。Chrome浏览器看本身的DNS缓存时间比较方便，在地址栏输入chrome://net-internals/#dns，就可以看到了查找操作系统缓存如果用户的浏览器缓存中没有，浏览器会从hosts文件查找是否有存储DNS信息，查找是否有目标域名和对应的IP地址查找路由器缓存如果系统缓存中也找不到，那么查询请求就会发向路由器，路由器一般会有自己的DNS缓存。查找ISP(Internet Service Provider) DNS 缓存如果路由器缓存中也找不到，那么就查询ISP DNS 缓存服务器了。我们都知道在我们的网络配置中都会有”DNS服务器地址”这一项，操作系统会把这个域名发送给这里设置的DNS，比如114.114.114.114,也就是本地区的域名服务器，通常是提供给你接入互联网的应用提供商。而114.114.114.114是国内移动、电信和联通通用的DNS。迭代查询如果前面都找不到DNS缓存的话，会有以下几个步骤：本地 DNS服务器将该请求转发到互联网上的根域（根域没有名字，在DNS系统中就用一个空字符串来表示。例如www.baidu.com.现在的DNS系统都不会要求域名以.来结束，即www.baidu.com就可以解析了，但是现在很多DNS解析服务商还是会要求在填写DNS记录的时候以.来结尾域名。）根域将所要查询域名中的顶级域（比如要查询www.baidu,com，该域名的顶级域就是com）的服务器IP地址返回到本地DNS。本地DNS根据返回的IP地址，再向顶级域（就是com域）发送请求， com域服务器再将域名中的二级域（即www.baidu.com中的baidu.com）的IP地址返回给本地DNS。本地DNS再向二级域发送请求进行查询。之后不断重复这样的过程，直到本地DNS服务器得到最终的查询结果，并返回到主机。这时候主机才能通过域名访问该网站。下图能很好的说明这个迭代查询:当查找到对应的IP地址之后，通过IP地址查找到对应的服务器，浏览器将用户发起的http请求发送给服务器。例如：GET http://www.baidu.com/ HTTP/1.1三、服务器处理请求每台服务器上都会安装处理请求的应用——Web server。常见的web server产品有apache、nginx、IIS、Lighttpd等。当web server接收到一个HTTP请求(request)，会返回一个HTTP响应(response)，例如送回一个HTML页面。对于不同用户发送的请求，会结合配置文件，把不同请求委托给服务器上处理对应请求的程序进行处理（例如CGI脚本，JSP脚本，servlets，ASP脚本，服务器端JavaScript，或者一些其它的服务器端技术等）。无论它们(脚本)的目的如何，这些服务器端(server-side)的程序通常产生一个HTML的响应(response)来让浏览器可以浏览。那么如何处理请求？实际上就是后台处理的工作。后台开发现在有很多框架，但大部分都还是按照MVC设计模式进行搭建的。处理的过程如下图：MVC的处理过程是这样的：对于每一个用户输入的请求，首先被控制器接收，控制器决定用哪个模型来进行处理，然后模型用业务逻辑来处理用户的请求并返回数据，最后控制器确定用哪个视图模型，用相应的视图格式化模型返回html字符串给浏览器，并通过显示页面呈现给用户。四、浏览器处理接下来就是浏览器进行处理， 通过后台处理返回的HTML字符串被浏览器接受后被一句句读取解析，html页面经历加载、解析、渲染。加载浏览器对一个html页面的加载顺序是从上而下的。如果加载过程中遇到外部css文件，浏览器另外发出一个请求，来获取css文件。遇到图片资源，浏览器也会另外发出一个请求，来获取图片资源。但是当文档加载过程中遇到js文件，html文档会挂起渲染（加载解析渲染同步）的线程，不仅要等待文档中js文件加载完毕，还要等待解析执行完毕，才可以恢复html文档的渲染线程。解析解析文档是指将文档转化成为有意义的结构，也就是可让代码理解和使用的结构。解析得到的结果通常是代表了文档结构的节点树，它称作解析树或者语法树，也就是DOM树。如下图：css解析是指将css文件解析为样式表对象。如下图：js解析是文件在加载的同时也进行解析如果想深入如何解析的话可以看浏览器的工作原理：新式网络浏览器幕后揭秘这篇文章渲染即为构建渲染树的过程，就是将DOM树进行可视化表示。构建这棵树是为了以正确的顺序绘制文档内容。五、绘制网页浏览器根据 HTML 和 CSS 计算得到渲染树，最终绘制到屏幕上参考的文章：前端经典面试题: 从输入URL到页面加载发生了什么？What really happens when you navigate to a URL从URL输入到页面展现MVC模型结构是什么域名详解浏览器~加载，解析，渲染由于本人的能力有限，如果哪里写的不对的话，请指出！感谢您的观看😀]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[前端学习笔记之js中apply()和call()方法详解]]></title>
      <url>%2F%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8Bjs%E4%B8%ADapply()%E5%92%8Ccall()%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3.html</url>
      <content type="text"><![CDATA[经过网上的大量搜索，渐渐明白了apply()和call方法的使用，为此写一篇文章记录一下。定义apply()方法：Function.apply(obj,args)obj：这个对象将代替Function类里this对象args：这个是数组，它将作为参数传给Function(args–&gt;arguments）call()方法：Function.call(obj,[param1[,param2[,…[,paramN]]]])obj：这个对象将代替Function类里this对象params：这个是一个参数列表相同点与不同点相同点作用是一样的，call 和 apply 都是为了改变函数体内部 this 的指向，也就是把Function(即this)绑定到obj，这时候obj具备了Function的属性和方法，说白一点就是obj继承了Function的属性和方法。不同点相信大家也已经发现了，他们唯一区别就是接受参数的方式不太一样，apply接受的是数组参数，call接受的是连续参数。方法使用我们来看下面一个例子：定义一个函数mul123function mul(a,b)&#123; return this+(a*b);&#125;接着我们在控制台上打印出12345console.log(mul.call(null,2,3));console.log(mul.call('s',2,3));console.log(mul.call(3,2,3));console.log(mul.apply(null,[2,5]));console.log(mul.apply(2,[2,5]));分别为：[object Window]6s69[object Window]1012可能你会发现到，第一行 console.log(mul.call(null,2,3)) 没什么变化，call()的第一个参数就是改变的 this 指向，如果为 null 则函数的 this 不变，注意，如果在严格模式下（函数体或全局的开头有这句话：’use strict’），this 会变成 null。如果函数本身有参数，则从 call 的第二个参数开始写起。第二行 console.log(mul.call(‘s’,2,3)) 将函数的 this 指向一个字符串 ‘s’. ===&gt;&gt; ‘s’+2 * 3=s6第三行 console.log(mul.call(3,2,3)) 将函数的this指向一个数字3===&gt;&gt; 3+2 * 3=9以此类推。再举一个例子学js的都知道 Math.max() 方法,比如有三个参数2,3,4那么我们要找出最大值可以这么写 Math.max(2,3,4) 那要是有 100 个或更多参数呢？这时候就可以结合 apply 和数组轻松实现了。比如定义一个数组var arr=[2,3,4,5,6,7,8,9,10,23,45,66,22,11];接着我们打印出console.log(Math.max.apply(null,arr));这样一来就很简洁明了。再举一个例子实现对象继承1234567891011function Person(name,age) &#123; this.name=name; this.age=age;&#125;var Student=function(name,age,gender) &#123; Person.call(this,name,age);//this继承了person的属性和方法 this.gender=gender;&#125;var student=new Student("陈安东", 20, "男");alert("姓名:"+student.name+"\n"+"年龄:"+student.age+"\n"+"性别:"+student.gender);输出姓名:陈安东年龄:20性别:男这样用call就实现了继承（用apply也类似）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[蓝桥杯-最大子阵]]></title>
      <url>%2F%E8%93%9D%E6%A1%A5%E6%9D%AF-%E6%9C%80%E5%A4%A7%E5%AD%90%E9%98%B5.html</url>
      <content type="text"><![CDATA[问题给定一个n*m的矩阵A，求A中的一个非空子矩阵，使这个子矩阵中的元素和最大。其中，A的子矩阵指在A中行和列均连续的一块。输入格式输入的第一行包含两个整数n, m，分别表示矩阵A的行数和列数。接下来n行，每行m个整数，表示矩阵A。输出格式输出一行，包含一个整数，表示A中最大的子矩阵中的元素和。样例输入3 3-1 -4 33 4 -1-5 -2 8样例输出10样例说明取最后一列，和为10。数据规模和约定对于50%的数据，1&lt;=n, m&lt;=50；对于100%的数据，1&lt;=n, m&lt;=500，A中每个元素的绝对值不超过5000。思路这题我是用动态规划求解，如下图，假设最大子矩阵的结果为从第r行到k行、从第i列到j列的子矩阵，如下所示(ari表示a[r][i],假设数组下标从1开始)：12345678910| a11 …… a1i ……a1j ……a1n || a21 …… a2i ……a2j ……a2n || ......................|| ...................... || ar1 …… ari ……arj ……arn || ......................|| ...................... || ak1 …… aki ……akj ……akn || ......................|| an1 …… ani ……anj ……ann |那么我们将从第r行到第k行的每一行中相同列的加起来，可以得到一个一维数组如下：(ar1+……+ak1, ar2+……+ak2, ……,arn+……+akn)，那么从中我们就可以把一个求子矩阵 的问题转换成一个求最大子段和 的问题，从中求出解。那么问题又来了，什么是最大子段和？怎么求最大子段和？首先，我们看一个问题：给定n个整数（可能为负数）组成的序列a[1],a[2],a[3],…,a[n],求该序列如a[i]+a[i+1]+…+a[j]的子段和的最大值比如当（a1,a2,a3,a4,a4,a6）=(-1,11,-1,13,-5,-2)时，最大子段和就为23。用动态算法求解:b[j]=max{a[i]+a[j]},1&lt;=i&lt;=j,且1&lt;=j&lt;=n,则所求的最大子段和为max b[j]，1&lt;=j&lt;=n。由b[j]的定义可易知，当b[j-1]&gt;0时b[j]=b[j-1]+a[j]，否则b[j]=a[j]。故b[j]的动态规划递归式为:b[j]=max(b[j-1]+a[j],a[j])，1&lt;=j&lt;=n。最大子段和算法123456789101112int getMaxArray(int a[],int n)&#123;//求最大子段和 int max=a[0],temp=0; for (int i=0;i&lt;n;i++) &#123; if (temp&gt;0) &#123; temp+=a[i]; &#125;else &#123; temp=a[i]; &#125; max=max&gt;temp?max:temp; &#125; return max;&#125;实现代码12345678910111213141516171819202122232425262728293031323334353637#include "stdio.h"#include&lt;string.h&gt;int dp[100];int getMaxArray(int a[],int n)&#123;//求最大子段和 int max=a[0],temp=0; for (int i=0;i&lt;n;i++) &#123; if (temp&gt;0) &#123; temp+=a[i]; &#125;else &#123; temp=a[i]; &#125; max=max&gt;temp?max:temp; &#125; return max;&#125;int main()&#123; int n,m; scanf("%d%d",&amp;n,&amp;m); int a[n][m]; for(int i=0;i&lt;n;i++)&#123; for (int j=0;j&lt;m;j++) &#123; scanf("%d",&amp;a[i][j]); &#125; &#125; int res=a[0][0],tmp; for (int i=0;i&lt;n;i++) &#123; memset(dp, 0, sizeof(dp));//将dp数组置为0 for (int j = i; j &lt; n; ++j) &#123; for (int k = 0; k &lt; m; ++k) &#123; dp[k] += a[j][k]; &#125; tmp = getMaxArray(dp, n); res = res &gt; tmp ? res : tmp; &#125; &#125; printf("%d\n", res);&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[蓝桥杯-四平方和问题]]></title>
      <url>%2F%E8%93%9D%E6%A1%A5%E6%9D%AF-%E5%9B%9B%E5%B9%B3%E6%96%B9%E5%92%8C%E9%97%AE%E9%A2%98.html</url>
      <content type="text"><![CDATA[问题：四平方和定理，又称为拉格朗日定理：每个正整数都可以表示为至多4个正整数的平方和。如果把0包括进去，就正好可以表示为4个数的平方和。比如：5 = 0^2 + 0^2 + 1^2 + 2^27 = 1^2 + 1^2 + 1^2 + 2^2（ ^ 符号表示乘方的意思）对于一个给定的正整数，可能存在多种平方和的表示法。要求你对4个数排序：0 &lt;= a &lt;= b &lt;= c &lt;= d并对所有的可能表示法按 a,b,c,d 为联合主键升序排列，最后输出第一个表示法程序输入为一个正整数N (N&lt;5000000)要求输出4个非负整数，按从小到大排序，中间用空格分开例如，输入：5则程序应该输出：0 0 1 2再例如，输入：12则程序应该输出：0 2 2 2再例如，输入：773535则程序应该输出：1 1 267 838资源约定：峰值内存消耗 &lt; 256MCPU消耗 &lt; 3000ms请严格按要求输出，不要画蛇添足地打印类似：“请您输入…” 的多余内容。所有代码放在同一个源文件中，调试通过后，拷贝提交该源码。注意: main函数需要返回0注意: 只使用ANSI C/ANSI C++ 标准，不要调用依赖于编译环境或操作系统的特殊函数。注意: 所有依赖的函数必须明确地在源文件中 #include， 不能通过工程设置而省略常用头文件。提交时，注意选择所期望的编译器类型。思路：这题我是用暴力输出的，用四个循环，我先前用四个循环是从小加到大，但是超时了。我发现，输入的数越大，输出的前两个数是比较小的，但是后面两个数比较大，于是我把后面两个循环变成从大减到小，于是成功了╮(￣▽￣)╭实现代码（用C语言实现）1234567891011121314151617181920212223#include&lt;stdio.h&gt;#include&lt;math.h&gt;void solve(long n)&#123; int a[4]; for (a[0]=0; a[0]&lt;sqrt(n); a[0]++) &#123; for (a[1]=a[0];a[1]&lt;sqrt(n) ; a[1]++) &#123; for (a[2]=sqrt(n-a[1]*a[1]-a[0]*a[0]); a[2]&gt;=a[1]; a[2]--) &#123; for (a[3]=sqrt(n-a[1]*a[1]-a[2]*a[2]-a[0]*a[0])+1; a[3]&gt;=a[2]; a[3]--) &#123;//其实这里加1不加1都一样 if (a[0]*a[0]+a[1]*a[1]+a[2]*a[2]+a[3]*a[3]==n) &#123; printf("%d %d %d %d\n",a[0],a[1],a[2],a[3]); return ; &#125; &#125; &#125; &#125; &#125;&#125;int main()&#123; long n; scanf("%ld",&amp;n); solve(n); return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[蓝桥杯-生日蜡烛]]></title>
      <url>%2F%E8%93%9D%E6%A1%A5%E6%9D%AF-%E7%94%9F%E6%97%A5%E8%9C%A1%E7%83%9B.html</url>
      <content type="text"><![CDATA[问题生日蜡烛某君从某年开始每年都举办一次生日party，并且每次都要吹熄与年龄相同根数的蜡烛。现在算起来，他一共吹熄了236根蜡烛。请问，他从多少岁开始过生日party的？请填写他开始过生日party的年龄数。注意：你提交的应该是一个整数，不要填写任何多余的内容或说明性文字。思路这题比较容易，方法是用两个for循环实现，第一个循环从i=1开始，第二个循环可以从j=i开始，内存循环sum+=j;而如果sum不等于236的话，在外层循环中将sum置为0就可以了实现代码(c语言)12345678910111213#include&lt;stdio.h&gt;int main()&#123; int i,sum = 0,j; for (i=1; i&lt;=100;i++) &#123; for(j=i;j&lt;=100;j++)&#123; sum+=j; if (sum==236) &#123; printf("%d",i); &#125; &#125; sum=0; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[蓝桥杯 三羊献瑞]]></title>
      <url>%2F%E8%93%9D%E6%A1%A5%E6%9D%AF-%E4%B8%89%E7%BE%8A%E7%8C%AE%E7%91%9E.html</url>
      <content type="text"><![CDATA[问题观察下面的加法算式：123456 祥 瑞 生 辉 + 三 羊 献 瑞================= 三 羊 生 瑞 气其中，相同的汉字代表相同的数字，不同的汉字代表不同的数字，‘三’和‘祥’不能为 0。请你计算出“三羊献瑞”所代表的 4 位数是什么。（答案唯一）注意：你提交的应该是一个整数，不要填写任何多余的内容或说明性文字，行末不要换行。思路这题我是直接用暴力法求解的(￣▽￣)”实现代码1234567891011121314151617181920212223242526#include&lt;stdio.h&gt;int main()&#123; int x,r,s,h,san,yan,xian,qi,sum1,sum2,sum3; for (x=1; x&lt;=9;x++) &#123; for (r=0; r&lt;=9; r++) &#123; for (s=0; s&lt;=9; s++) &#123; for (h=0; h&lt;=9; h++) &#123; for (san=1; san&lt;=9; san++) &#123; for (yan=0; yan&lt;=9; yan++) &#123; for (xian=0; xian&lt;=9; xian++) &#123; for (qi=0; qi&lt;=9; qi++) &#123; sum1=x*1000+r*100+s*10+h; sum2=san*1000+yan*100+xian*10+r; sum3=san*10000+yan*1000+s*100+r*10+qi; if (sum1+sum2==sum3 &amp;&amp; x!=r &amp;&amp; x!=s &amp;&amp; x!=h &amp;&amp; x!=san &amp;&amp; x!=yan &amp;&amp; x!=xian &amp;&amp; x!=qi &amp;&amp; r!=s &amp;&amp; r!=h &amp;&amp; r!=san &amp;&amp; r!=h &amp;&amp; r!=san &amp;&amp; r!=yan &amp;&amp; r!=xian &amp;&amp; r!=qi &amp;&amp;s!=h &amp;&amp; s!=san &amp;&amp; s!=yan &amp;&amp; s!=xian &amp;&amp; s!=qi &amp;&amp;h!=san &amp;&amp;h!=yan &amp;&amp;h!=xian &amp;&amp; h!=qi &amp;&amp;san!=yan &amp;&amp;san!=qi&amp;&amp; yan!=xian &amp;&amp; yan!=qi &amp;&amp;xian!=qi) &#123; printf("%d+%d=%d\n",sum1,sum2,sum3); &#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[next主题如何添加动态背景]]></title>
      <url>%2Fhexo%E5%A6%82%E4%BD%95%E6%B7%BB%E5%8A%A0%E5%8A%A8%E6%80%81%E8%83%8C%E6%99%AF.html</url>
      <content type="text"><![CDATA[注意：如果next主题在5.1.1以上的话就不用我这样设置，直接在主题配置文件中找到canvas_nest: false，把它改为canvas_nest: true就行了（注意分号后面要加一个空格）其实挺简单的︿(￣︶￣)︿修改_layout.swig打开 next/layout/_layout.swig在 &lt; /body&gt;之前添加代码(注意不要放在&lt; /head&gt;的后面)123&#123;% if theme.canvas_nest %&#125;&lt;script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"&gt;&lt;/script&gt;&#123;% endif %&#125;修改配置文件打开 /next/_config.yml,在里面添加如下代码：(可以放在最后面)123456# --------------------------------------------------------------# background settings# --------------------------------------------------------------# add canvas-nest effect# see detail from https://github.com/hustcc/canvas-nest.jscanvas_nest: true到此就结束了，运行 hexo clean，然后运行 hexo g,然后运行 hexo s，最后打开浏览器在浏览器的地址栏输入 localhost:4000 就能看到效果了\（￣︶￣）/如果你感觉默认的线条太多的话可以这么设置====&gt;在上一步修改 _layout.swig中，把刚才的这些代码：123&#123;% if theme.canvas_nest %&#125;&lt;script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"&gt;&lt;/script&gt;&#123;% endif %&#125;改为1234&#123;% if theme.canvas_nest %&#125;&lt;script type="text/javascript"color="0,0,255" opacity='0.7' zIndex="-2" count="99" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"&gt;&lt;/script&gt;&#123;% endif %&#125;配置项说明color ：线条颜色, 默认: &#39;0,0,0&#39;；三个数字分别为(R,G,B)opacity: 线条透明度（0~1）, 默认: 0.5count: 线条的总数量, 默认: 150zIndex: 背景的z-index属性，css属性用于控制所在层的位置, 默认: -1]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[蓝桥杯 李白喝酒]]></title>
      <url>%2F%E8%93%9D%E6%A1%A5%E6%9D%AF%20%E6%9D%8E%E7%99%BD%E5%96%9D%E9%85%92%EF%BC%81.html</url>
      <content type="text"><![CDATA[问题话说大诗人李白，一生好饮。幸好他从不开车。一天，他提着酒壶，从家里出来，酒壶中有酒两斗。他边走边唱：无事街上走，提壶去打酒。逢店加一倍，遇花喝一斗。这一路上，他一共遇到店 55 次，遇到花 1010 次，已知最后一次遇到的是花，他正好把酒喝光了。请你计算李白遇到店和花的次序，有多少种可能的方案。思路我们已知遇店 5 次，遇花 10 次，并且最后一次遇到花，正好把酒喝光。那么我们可以把店作为二进制中的 1，把花作为二进制中的 0，因为已经确定最后一次遇到的是花，所以我们需要判断枚举的结果是否刚好有 5个 1 和 9个 0。那么我们就枚举出 14 位二进制的所有可能并加以判断即可，判断思路为判断二进制是否有 9 个 0，5个 1，并且最终酒刚好剩 1 斗实现代码12345678910111213141516171819202122#include&lt;stdio.h&gt;int main()&#123; int ans=0;//方案数 for (int i=0; i&lt;(1&lt;&lt;14); i++) &#123; int dian=0;//表示遇到店的次数 int hua=0;//表示遇到话的次数 int num=2;//初始酒壶有两斗 for (int j=0;j&lt;14 ;j++) &#123; if (i&amp;(1&lt;&lt;j)) &#123;//这里判断二进制i从右数第j+1为是否为1 dian++;//遇到店，次数加1 num*=2;//加一倍 &#125;else&#123; hua++;//遇到花，次数加1 num-=1;//喝一斗 &#125; &#125; if (dian==5&amp;&amp;hua==9&amp;&amp;num==1) &#123; ++ans;//记录方法数 &#125; &#125; printf("%d\n",ans);&#125;]]></content>
    </entry>

    
  
  
</search>
